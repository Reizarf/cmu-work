;
;
;       ***** MDIAG - EXTENSIVE MEMORY DIAGNOSTIC *****;
;
;           AUTHOR: WAYNE WALL
;                   CSM COMPUTING CENTER
;                   GOLDEN, COLO.  80401

    .PAGE               ;'DEFINITIONS AND PAGE ZERO STUFF'
    
    .DEF    RESETV = $FFFC  ;ADDRESS OF 6502 RESET VECTOR

    .LOC    $0056       ; DEFINE START OF PAGE ZERO USAGE

    ;DEFINE USEFUL PAGE ZERO TEMPORARIES


LOWPAG: .BYTE   $C0     ;*** PATCH THIS TO PAGE # TO START TESTING
HIPAG:  .BYTE   $D0     ;*** PATCH THIS TO PAGE # +1 TO END TESTING

    .DEF    ADDR=.      ;THIS POINTS TO MEMORY ADDR BEING REFERENCED

ADDRL:  .BYTE   0       ;LOW ORDER
ADDRH:  .BYTE   0       ;HIGH ORDER

    .DEF    ADDRSV=.    ;THIS POINTS TO A SPECIAL MEMORY ADDRESS

ADRSVL: .BYTE   0       ;LOW ORDER
ADRSVH: .BYTE   0       ;HIGH ORDER

TEMP:   .BYTE   0       ;GENERAL PURPOSE TEMPORARY
ACSAV:  .BYTE   0       ;GENERAL PLACE TO SAVE THE ACCUMULATOR

PAT:    .BYTE   0       ;HOLDS THE CURRENT TEST PATTERN
PAT2:   .BYTE   0       ;HOLDS A SECOND PATTERN FOR SOME TESTS

TEST:   .BYTE   0       ;HOLDS TEST NUMBER OF CURRENT TEST

PNUM:   .BYTE   0       ;HOLDS THE NUMBER OF PASSES FOR A GIVEN TEST

PCNT:   .BYTE   0       ;HOLDS THE CURRENT PASS COUNTER

ERRPNT: .BYTE   0       ;HOLDS POINTER INTO ERROR INFO TABLE

PAUSEF: .BYTE   0       ;= 0 MEANS DON'T PAUSE AFTER AN ERROR

CMDPNT: .BYTE   0       ;HOLDS OFFSET TO 'CMDTAB' COMMAND TABLE

CALCN1: .BYTE   0       ;COUNTER USED BY SOME TESTS
CALCN2: .BYTE   0       ;COUNTER USED BY SOME TESTS

JSRIND: JMP $0000       ;ADDR OF 'JMP' IS MODIFIED

    .PAGE               ;'MORE PAGE ZERO STUFF'

    ;MESSAGE STRINGS USED BY PROGRAM

MESS1:  .ASCII  'T#'
        .BYTE   0

MESS2:  .ASCII  ' @ '
        .BYTE   0

MESS3:  .ASCII  ' BAD='
        .BYTE   0

MESS4:  .ASCII  ' GOOD='
        .BYTE   0

MESS5:  .ASCII  ' P#'
        .BYTE   0
        
MESSP:  .ASCII  'PAUSING...'
        .BYTE   0
        
    .PAGE                   ;'MAIN PROGRAM LOOP'

    .LOC    $0200           ; DEFINE WHERE THIS THING GOES IN MEMORY
    
    .DEF    ERRTAB = .      ;PLACE ERROR INFORMATION TABLE HERE

    .LOC    .+$0100         ;IT IS ONE PAGE LONG    

    ;*** PROGRAM STARTS HERE ***

START:  SEI                 ;DISABLE IRQ GRANTING
        CLD                 ;CLEAR DECIMAL MODE
        LDX#    $FF         ;INIT STACK POINTER
        TXS
        JSR     CONINI      ;INIT CONSOLE INPUT
        JSR     CONINO      ;INIT CONSOLE OUTPUT
        JSR     CRLF        ;ADVANCE ONE LINE
START1: LDX#    $FF         ;HERE TO SCAN COMMAND LIST
        STX     CMDPNT      ;STORE $FF INTO COMMAND POINTER
CMDL:   INC     CMDPNT      ;POINT TO NEXT COMMAND IN COMMAND TABLE
        LDX     CMDPNT      ;GET POINTER
        LDAX    CMDTAB      ;GET THE NUMBER OF THE TEST TO DO
        BEQ     START1      ;ZERO INDICATES COMMAND LIST EXHAUSTED.  START OVER
        STA     TEST        ;SAVE THE TEST NUMBER FOR LATER
        INX                 ;POINT TO NEXT BYTE IN COMMAND TABLE
        LDAX    CMDTAB      ;GET NUMBER OF TIMES TO DO THIS TEST
        STA     PNUM        ;STORE IT AWAY
        INX                 ;POINT TO NEXT BYTE IN COMMAND TABLE
        STX     CMDPNT      ;SAVE POINTER FOR LATER
        LDAX    CMDTAB      ;GET NEXT BYTE FROM COMMAND TABLE
        STA     PAUSEF      ;STORE AS FLAG FOR PAUSING
        LDA     TEST        ;GET THE TEST NUMBER
        ASLA                ;TIMES TWO TO FORM OFFSET INTO 'ADRTAB'
        TAX                 ;INTO X REGISTER
        LDAX    ADRTAB      ;GET LOW ORDER BYTE OF ADDR OF TEST ROUTINE
        STA     JSRIND+1    ;SAVE IT
        LDAX    ADRTAB+1    ;GET HIGH ORDER BYTE OF ADDR OF TEST ROUTINE
        STA     JSRIND+2    ;SAVE IT
        JSR     OUTEST      ;ANNOUNCE THE TEST WE ARE STARTING
        JSR     CRLF
        LDA#    1           ;INIT PASS COUNTER TO ONE
        STA     PCNT
DOTEST: JSR     JSRIND      ;NOW CALL THE ROUTINE THAT DOES THE TEST
        JSR     CONICK      ;HAS USER TYPED A KEY WHILE WE WERE DOING THE TEST?
        BCS     NOKEY       ;BRANCH IF NOT, CONTINUE ON...
        CMP#    'Q          ;DOES USER WANT TO QUIT THIS PROGRAM?
        BNE     NOQUIT      ;BRANCH IF NOT
        JMP@    RESETV      ;SIMULATE RESET TO ENTER THE DEBUGGER.
NOQUIT: CMP#    'P          ;DOES USER WANT TO PAUSE?
        BNE     NOKEY       ;BRANCH IF NOT, CONTINUE ON...
        JSR     CRLF        ;DISPLAY MESSAGE
        LDX#    MESSP
        JSR     OUTSTR
        JSR     CRLF
        JSR     CONINP      ;RESUME WHEN ANY KEY IS STRUCK.
NOKEY:  LDA     PCNT        ;GET PASS NUMBER
        CMP     PNUM        ;HAVE WE REACHED NUMBER REQUESTED?
        BEQ     CMDL        ;BRANCH IF WE HAVE, PROCESS NEXT COMMAND
        INC     PCNT        ;NO, THEN BUMP PASS NUMBER
        JMP     DOTEST      ;AND DO THE TEST AGAIN

    .PAGE       ;'MEMORY TEST DRIVER ROUTINES'


;*** TEST 1 - ALL ZEROES, ALL ONES ***

MTEST1: LDA#    0           ;NOW WRITE ZEROES
        STA     PAT
        JSR     WRTPAT      ;INTO ALL MEMORY LOCS
        JSR     RDPAT       ;NOW READ AND VERIFY THEY ARE STILL THERE
        LDA#    $FF         ;NOW WRITE ONES
        STA     PAT
        JSR     WRTPAT      ;INTO ALL MEMORY LOCS
        JMP     RDPAT       ;* PJMP * READ AND VERIFY THEY ARE STILL THERE
                            ;   THEN RETURN.

;*** TEST 2 - FLOAT A ONE, THEN FLOAT A ZERO ***

MTEST2: LDA#    1           ;START A ONE IN THE LSB
        STA     PAT
M2LP1:  JSR     WRTPAT      ;WRITE PATTERN IN ALL MEMORY LOCS
        JSR     RDPAT       ;NOW VERIFY IT'S STILL THERE
        ASL     PAT         ;MOVE THE ONE TO THE LEFT
        BNE     M2LP1       ;AND LOOP TILL ALL BIT POSITIONS TESTED
        LDA#    1           ;NOW TURN ON THE LSB
M2LP2:  PHA                 ;SAVE MASK FOR LATER
        EOR#    $FF         ;MAKE BIT A ZERO, ALL OTHERS A ONE
        STA     PAT         ;STORE AS CURRENT PATTERN
        JSR     WRTPAT      ;WRITE THE PATTERN IN ALL MEMORY LOCS
        JSR     RDPAT       ;READ AND VERIFY IT IS STILL THERE
        PLA                 ;GET MASK BACK
        ASLA                ;SHIFT ONE TO THE LEFT
        BNE     M2LP2       ;AND LOOP IF MORE TO DO
        RTS                 ;OTHERWISE RETURN
        
    .PAGE       ;'MEMORY TEST DRIVER ROUTINES'

;*** TEST 3 - QUICK TEST FOR ADDRESS/DATA INTERACTION

MTEST3: LDA#    0           ;START WITH ALL ZEROES
        STA     PAT
        JSR     WRTPAT      ;WRITTEN INTO MEMORY
        JSR     RESADR      ;RESET POINTER TO START OF MEMORY
        LDY#    0           ;MAKE SURE OFFSET IS ZERO
SCNUP1: LDA@Y   ADDR        ;DOES THE LOC STILL CONTAIN A ZERO?
        BEQ     SCNC1       ;BRANCH IF YES, ITS OK
        JSR     PRNTER      ;*** ERROR! PRINT IT ***
SCNC1:  LDA#    $FF         ;GET ALL ONES
        STA@Y   ADDR        ;REPLACE CONTENTS WITH ALL ONES
        JSR     INCADR      ;BUMP TO NEXT ADDRESS
        BCC     SCNUP1      ;AND CONTINUE TO SCAN FOR ALL ZEROES UPWARD
        JSR     RESHGH      ;NOW RESET TO HIGHEST ADDR
        LDA#    $FF         ;INDICATE WE ARE NOW LOOKING FOR ALL ONES
        STA     PAT
SCNDN1: LDA@Y   ADDR        ;READ THE LOC
        CMP#    $FF         ;DOES IT STILL HAVE ALL ONES?
        BEQ     SCNC2       ;BRANCH IF IT DOES, IT'S OK
        JSR     PRNTER      ;*** ERROR! PRINT IT ***
SCNC2:  LDA#    0           ;NOW REPLACE WITH ALL ZEROES
        STA@Y   ADDR
        JSR     CHKSAV      ;HAVE WE REACHED THE BOTTOM YET?
        BEQ     SCNAGN      ;BRANCH IF YES
        JSR     DECADR      ;NO, THEN MOVE DOWN ONE LOC
        JMP     SCNDN1      ;AND CONTINUE TO SCAN DOWN
        
    .PAGE       ;'MEMORY TEST DRIVER ROUTINES'

    ;MORE OF TEST 3

SCNAGN: JSR     RESHGH      ;SET ADDR POINTER TO HIGHEST LOC
        LDA#    0           ;INDICATE WE ARE NOW LOOKING
        STA     PAT         ;FOR ALL ZEROES TO STILL BE THERE
SCNDN2: LDA@Y   ADDR        ;READ THE LOC
        BEQ     SCNC3       ;BRANCH IF ITS OK
        JSR     PRNTER      ;*** ERROR! PRINT IT ***
SCNC3:  LDA#    $FF         ;NO REPLACE WITH ALL ONES
        STA@Y   ADDR
        JSR     CHKSAV      ;CHECK TO SEE IF WE HAVE REACHED BOTTOM?
        BEQ     SCNAG2      ;BRANCH IF YES
        JSR     DECADR      ;NO, THEN STEP DOWN ONE LOC
        JMP     SCNDN2      ;AND CONTINUE SCANNING DOWNWARD
SCNAG2: LDA#    $FF         ;INDICATE WE ARE NOW LOOKING FOR ALL ONES
        STA     PAT
        JSR     RESADR      ;SET ADDR POINTER TO LOWEST LOC
SCNUP2: LDA@Y   ADDR        ;READ LOC
        CMP#    $FF         ;DOES IT STILL CONTAIN ALL ONES?
        BEQ     SCNC4       ;BRANCH IF IT DOES, ITS OK
        JSR     PRNTER      ;*** ERROR! PRINT IT ***
SCNC4:  LDA#    0           ;NOW REPLACE WITH AT ZERO
        STA@Y   ADDR
        JSR     INCADR      ;NOW POINT TO NEXT HIGHER LOC
        BCC     SCNUP2      ;AND CONTINUE TO SCAN UPWARD
        LDA#    0           ;INDICATE WE ARE
        STA     PAT         ;LOOKING FOR MEMORY TO CONTAIN ALL ZEROES
        JMP     RDPAT       ;* PJMP * VERIFY THAT IT DOES, THEN RETURN
        
    .PAGE       ;'MEMORY TEST DRIVER ROUTINES'

;*** TEST 4 - ANOTHER QUICK ADDRESS/DATA INTERACTION TEST

MTEST4: JSR     RESADR      ;RESET ADDRESS POINTER TO START OF MEMORY
        LDY#    0           ;MAKE SURE OFFSET IS ZERO
MT4WRT: JSR     GENNUM      ;GENERATE MAGIC NUMBER FOR THIS LOC
        STA@Y   ADDR        ;STORE IT IN THE ADDRESS
        JSR     INCADR      ;POINT TO NEXT
        BCC     MT4WRT      ;KEEP WRITING IF MORE LOCS
        JSR     RESADR      ;RESET ADDRESS POINTER TO START OF MEMORY
MT4RED: JSR     GENNUM      ;GENERATE MAGIC NUMBER FOR THIS LOC
        STA     PAT         ;SAVE IT AS GOOD DATA
        LDA@Y   ADDR        ;READ LOC
        CMP     PAT         ;DOES IT HAVE WHAT IT IS SUPPOSED TO HAVE?
        BEQ     MT4RDC      ;BRANCH IF YES, IT'S OK
        JSR     PRNTER      ;*** ERROR! PRINT IT ***
MT4RDC: JSR     INCADR      ;POINT TO NEXT ADDRESS
        BCC     MT4RED      ;AND CHECK NEXT LOC
                            ;FALL INTO NEXT PAGE TO TEST IN OTHER DIRECTION
                        
    .PAGE       ;'MEMORY TEST DRIVER ROUTINES'

;MORE OF TEST 4

MT4DWN: JSR     RESHGH      ;SET POINTERS TO HIGHEST MEMORY ADDRESS
MT4WTD: JSR     GENNUM      ;GENERATE MAGIC NUMBER FOR THIS LOC
        STA@Y   ADDR        ;STORE IT IN THE LOC
        JSR     CHKSAV      ;HAVE WE HIT THE BOTTOM YET?
        BEQ     MT4C1       ;BRANCH IF YES
        JSR     DECADR      ;NO, THEN POINT DOWN ONE LOC
        JMP     MT4WTD      ;AND WRITE PATTERN INTO IT
MT4C1:  JSR     RESHGH      ;RESET ADDRESS POINTER TO HIGHEST MEM ADDRESS
MT4RDD: JSR     GENNUM      ;GENERATE THE MAGIC NUMBER FOR THIS LOC
        STA     PAT         ;SAVE AS GOOD DATA
        LDA@Y   ADDR        ;GET THE DATA FROM THE ADDRESS
        CMP     PAT         ;IS IT WHAT IT SHOULD BE?
        BEQ     MT4C2       ;BRANCH IF IT IS
        JSR     PRNTER      ;*** ERROR! PRINT IT ***
MT4C2:  JSR     CHKSAV      ;HAVE WE HIT BOTTOM OF MEMORY AREA YET?
        BEQ     MT4RET      ;BRANCH IF YES
        JSR     DECADR      ;NO, THEN DROP DOWN ONE LOC
        JMP     MT4RDD      ;AND CHECK THAT ONE
MT4RET: RTS                 ;RETURN WHEN ALL DONE

;ROUTINE TO GENERATE THE MAGIC NUMBER FOR THIS LOC.
;MAGIC NUMBER IS THE SUM OF THE PAGE NUMBER, THE BYTE NUMBER,
;AND THE PASS NUMBER.

GENNUM: LDX     PCNT        ;GET THE PASS COUNT
        DEX                 ;FIRST PASS IS 0, ETC
        TXA
        CLC
        ADC     ADDRH       ;ADD IN THE PAGE NUMBER
        CLC
        ADC     ADDRL       ;ADD IN THE BYTE NUMBER
        RTS                 ;AND RETURN WITH NUMBER IN THE ACCUMULATOR
        
    .PAGE       ;'MEMORY TEST DRIVER ROUTINES'

;*** TEST 5 - FAST FETCH AND CROSSTALK AGITATOR
;         WITH MEMORY HEATING.

MTEST5: JSR     RESADR      ;RESET ADDR POINTER TO START OF MEMORY
        LDA#    $B4         ;GET MAGIC SUM
        STA     PAT         ;STORE AS THE GOOD DATA (FOR ERROR REPORTING)
MT5LOP: LDY#    0           ;MAKE SURE OFFSET IS ZERO
STOINS: LDA#    $69         ;GET OPCODE FOR 'ADC#' INSTRUCTION
        STA@Y   ADDR        ;STORE IT IN THE MEMORY PAGE
        JSR     INCADR      ;BUMP POINTER
        LDA#    $96         ;USE COMPLEMENT OF INSTRUCTION AS DATA
        STA@Y   ADDR        ;USED BY INSTRUCTION (KEEPS BITS FLIPPING)
        JSR     INCADR
        LDA     ADDRL       ;GET POSITION ON THE PAGE
        CMP#    $FE         ;HAVE WE INSERTED 127 'ADC#  $96' INSTRUCTIONS?
        BNE     STOINS      ;BRANCH IF NOT, KEEP INSERTING
        LDA#    $60         ;GET AN 'RTS' OPCODE
        STA@Y   ADDR        ;STORE IT IN THE PAGE
        JSR     INCADR
        LDA#    $60         ;STORE ANOTHER 'RTS' AT END OF PAGE
        STA@Y   ADDR        ;FOR GOOD MEASURE
        LDA     ADDRH       ;NOW MOVE ADDRESS OF FIRST
        STA     JSRIND+2    ;LOC ON THE PAGE
        LDA#    0
        STA     JSRIND+1    ;AS THE LOCATION OF THE SUBROUTINE
        STA     CALCN1      ;ZERO OUT COUNTER OF TIMES TO CALL
        STA     CALCN2      ;OUTER COUNTER ALSO
CALLP:  LDA#    0           ;SET SUM TO ZERO
        CLC                 ;AND MAKE SURE CARRY IS CLEAR
        JSR     JSRIND      ;CALL THE SUBROUTINE WHICH OCCUPIES THIS PAGE
        BCS     ERRCAL      ;CORRECT SUM HAS CARRY CLEAR!
        CMP     PAT         ;CARRY IS OK, BUT IS SUM OK?
        BEQ     SUMOK       ;BRANCH IF YES
ERRCAL: JSR     PRNTER      ;*** ERROR! PRINT IT ***
SUMOK:  DEC     CALCN1      ;DONE 256 CALLS TO CODE YET?
        BNE     CALLP       ;BRANCH IF NOT, HEAT THE MEMORY SOME MORE!
        DEC     CALCN2      ;YES, NOW DO 256*256 CALLS
        BNE     CALLP       ;DONE?
        JSR     INCADR      ;YES, MOVE TO NEXT PAGE
        BCC     MT5LOP      ;AND DO IT
        RTS                 ;UNTIL WE HAVE REACHED THE END
        
    .PAGE       ;'MEMORY TEST DRIVER ROUTINES'

;*** TEST 6 - SUPER MUNGER FOR ADDRESS/DATA INTERACTIONS AND LEAKAGE
;
;    THIS TEST RUNS A VERY LONG TIME!  IT IS NOT INCLUDED IN THE
;    STANDARD COMMAND LIST, BUT CAN BE INSERTED MANUALLY IF YOU
;    WANT AN EXHAUSTIVE TEST OF ALL POSSIBLE DATA PATTERNS IN ALL
;    POSSIBLE LOCS.

MTEST6: JSR     RESADR      ;RESET ADDR POINTER TO START OF MEMORY SEGMENT
        LDY#    0           ;MAKE SURE OFFSET IS ZERO
        STY     PAT         ;START WITH AN INITIAL PATTERN OF ZERO
MT6LOP: JSR     WRTPAT      ;WRITE THE DATA PATTERN IN MEMORY
        JSR     RESADR      ;RESET ADDR POINTER TO START OF MEMORY
        LDA     PAT         ;FORM THE
        EOR#    $FF         ;COMPLEMENT OF THE PATTERN
        STA     PAT2        ;SAVE FOR LATER USE
MT6C0:  LDA@Y   ADDR        ;READ THE LOC
        CMP     PAT         ;IS THE DATA PATTERN STILL THERE?
        BEQ     MT6C1       ;BRANCH IF IT IS
        JSR     PRNTER      ;*** ERROR! PRINT IT ***
MT6C1:  LDA     PAT2        ;NOW STORE THE COMPLEMENT IN THAT LOC
        STA@Y   ADDR
        JSR     SAVADR      ;NOW REMEMBER WHERE
        LDA     ADDRH       ;SAVE ADDR POINTER
        PHA                 ;ON STACK
        LDA     ADDRL       ;WHILE WE LOOK AT ALL LOCS
        PHA
        JSR     RESADR      ;START AT BOTTOM TO LOOK AT ALL LOCS
MT6LP1: JSR     CHKSAV      ;IS THIS WHERE WE STORED THE COMPLEMENT?
        BEQ     MT6C3       ;BRANCH IF YES
        LDA@Y   ADDR        ;NO, READ THE LOC
        CMP     PAT         ;IS THE DATA OK?
        BEQ     MT6C2       ;BRANCH IF ITS OK
        JSR     PRNTER      ;*** ERROR! PRINT IT ***
MT6C2:  JSR     INCADR      ;BUMP TO NEXT ADDR
        BCC     MT6LP1      ;CHECK ALL LOCS
        BCS     MT6C4       ;CHECKED THEM ALL, DATA DID NOT APPEAR ELSEWHERE
MT6C3:  LDA     PAT         ;SAVE PATTERN
        PHA
        LDA     PAT2        ;USE COMPLEMENT
        STA     PAT         ;FOR ERROR PRINT ROUTINES
        LDA@Y   ADDR        ;READ LOC
        CMP     PAT         ;IT SHOULD CONTAIN THE COMPLEMENT
        BEQ     MT6C3A      ;BRANCH IF IT DOES
        JSR     PRNTER      ;*** ERROR! PRINT IT ***
MT6C3A: PLA                 ;RESTORE PATTERN
        STA     PAT
        JMP     MT6C2       ;AND CHECK NEXT LOC
        
    .PAGE       ;'MEMORY TEST DRIVER ROUTINES'

;MORE OF TEST 6

MT6C4:  PLA                 ;RESTORE ADDR OF WHERE
        STA     ADDRL       ;WE STUCK THE COMPLEMENT
        PLA
        STA     ADDRH
        LDA     PAT         ;NOW REPLACE WITH DATA PATTERN
        STA@Y   ADDR
        JSR     INCADR      ;MOVE TO NEXT HIGHER ADDR
        BCC     MT6C0       ;AND CHECK THAT ONE
        INC     PAT         ;ALL DONE WITH THIS PATTERN, MOVE TO NEXT
        BNE     MT6LOP      ;USE IT NOW (SEE WHY THIS TAKES FOREVER!)
        RTS                 ;USED ALL PATTERNS, RETURN
        
    .PAGE       ;'MEMORY TEST DRIVER ROUTINES'

;*** TEST 7 - TEST FOR LEAKY CHIPS.  THIS TEST SIMULATES A
;LOAD FROM CASSETTE, WAITS FOR ONE MINUTE, THEN
;CHECKS TO SEE IF DATA IS VALID.

MTEST7: LDA#    $FF         ;FIRST USE DATA PATTERN OF ALL ONES
        JSR     MTST7
        LDA#    0           ;THEN USE DATA PATTERN OF ALL ZEROES
                            ;* PFALL * FALL INTO TEST, THEN RETURN

MTST7:  STA     PAT         ;SAVE DATA PATTERN
        JSR     RESADR      ;RESET ADDR POINTER TO START OF MEMORY
        LDY#    0           ;MAKE SURE OFFSET IS ZERO
MT7WT1: LDA     PAT         ;STORE PATTERN IN MEMORY
        STA@Y   ADDR
        LDA#    0           ;ZERO ACCUMULATOR FOR DRILL
        LDA@Y   ADDR        ;READ THE LOC BACK
        CMP     PAT         ;DOES IT STILL CONTAIN THE DATA?
        BEQ     MT7C1       ;BRANCH IF IT DOES
        JSR     PRNTER      ;*** ERROR! PRINT IT ***
MT7C1:  JSR     CDELAY      ;DELAY ONE CASSETTE CHAR TIME
        JSR     INCADR      ;POINT TO NEXT ADDRESS
        BCC     MT7WT1      ;AND WRITE PATTERN IN NEXT LOC
        JSR     DEL64       ;NOW DELAY FOR ONE MINUTE
        JSR     RESADR      ;RESET ADDR POINTER TO START OF MEMORY
        LDY#    0           ;MAKE SURE OFFSET IS ZERO
MT7RD1: LDA@Y   ADDR        ;READ THE LOC
        CMP     PAT         ;SEE IF IT STILL CONTAINS THE DATA
        BEQ     MT7C2       ;BRANCH IF IT DOES
        JSR     PRNTER      ;*** ERROR! PRINT IT ***
MT7C2:  JSR     INCADR      ;POINT TO NEXT ADDR
        BCC     MT7RD1      ;AND READ IT
        RTS                 ;AND RETURN WHEN ALL DONE
        
    .PAGE       ;'MEMORY TEST DRIVER ROUTINES'

;*** TEST 8 - EXTENDED TEST FOR LEAKY CHIPS

MTEST8: JSR     RESADR      ;RESET ADDR POINTER TO START OF MEMORY
        LDY#    0           ;MAKE SURE OFFSET IS ZERO
MT8LP1: JSR     GENNUM      ;GENERATE MAGIC NUMBER FOR THIS LOC
        STA@Y   ADDR        ;STORE IT IN THE LOC
        JSR     INCADR      ;BUMP TO NEXT HIGHER LOC
        BCC     MT8LP1      ;AND KEEP STORING
MT8LP2: JSR     RESADR      ;RESET TO START OF MEMORY AREA
        JSR     DEL1        ;GO DELAY ONE SECOND
MT8LP3: JSR     GENNUM      ;GENERATE MAGIC NUMBER FOR THIS LOC
        STA     PAT         ;SAVE IT AS GOOD DATA
        LDA@Y   ADDR        ;READ LOC
        CMP     PAT         ;DOES IT CONTAIN WHAT IT SHOULD?
        BEQ     MT8C1       ;BRANCH IF YES
        JSR     PRNTER      ;*** ERROR! PRINT IT ***
MT8C1:  JSR     INCADR      ;BUMP TO NEXT ADDR
        BCC     MT8LP3      ;AND CHECK THEM ALL
        RTS                 ;AND RETURN WHEN ALL DONE
        
    .PAGE       ;' TIME DELAY ROUTINES '

    ;LONG DELAYS

DEL64:  JSR     DEL32       ;DELAY 32, THEN 32 MORE
DEL32:  JSR     DEL16       ;DELAY 16, THEN 16 MORE
DEL16:  JSR     DEL8        ;DELAY 8, THEN 8 MORE
DEL8:   JSR     DEL4        ;DELAY 4, THEN 4 MORE
DEL4:   JSR     DEL2        ;DELAY 2, THEN 2 MORE
DEL2:   JSR     DEL1        ;DEALY 1, THEN 1 MORE
DEL1:   JSR     DEL250      ;DELAY FOR 4*250 MILLISECS
        JSR     DEL250
        JSR     DEL250

;DELAY FOR 250 MILLISECS

DEL250: TXA                 ;SAVE X REGISTER
        PHA                 ;ON STACK
        LDX#    247         ;INIT X COUNTER
DXNLOP: LDY#    201         ;INIT Y COUNTER
DYNLOP: DEY                 ;KILL TIME
        BNE DYNLOP
        DEX
        BNE DXNLOP
        PLA                 ;RESTORE X REGISTER
        TAX
        JSR DUMMY           ;BURN 24 CYCLES TO GET IT EXACT
        JSR DUMMY
DUMMY:  RTS

    .PAGE       ;' TIME DELAY ROUTINES '

    ;ROUTINE TO DELAY FOR ONE CHARACTER TIME AT 1100 BAUD

CDELAY: LDX#    22          ;DELAY FOR 22 HALF-BIT TIMES
CLOOP:  JSR     BDELAY      ;DELAY ONE HALF BIT TIME
        DEX
        BNE     CLOOP       ;LOOP FOR 11 BIT TIMES
        RTS

;ROUTINE TO DELAY FOR ONE HALF BIT TIME AT 1100 BAUD
;USED TO SIMULATE CASSETTE LOADING

BDELAY: TYA                 ;SAVE REGISTERS
        PHA
        TXA
        PHA
        LDX     XCOUNT      ;GET OUTER LOOP COUNTER
XINLOP: LDY     YCOUNT      ;GET INNER LOOP COUNTER
YINLOP: DEY                 ;KILL TIME
        BNE     YINLOP
        DEX
        BNE     XINLOP
        PLA                 ;RESTORE REGISTERS
        TAX
        PLA
        TAY
        RTS

XCOUNT: .BYTE   1
YCOUNT: .BYTE   78

    .PAGE       ;'ROUTINES TO WRITE AND READ MEMORY'

;ROUTINE TO WRITE THE DATA IN 'PAT' INTO ALL MEMORY LOCS.

WRTPAT: JSR     RESADR      ;RESET POINTERS TO START OF MEMORY SEGMENT
        LDY#    0           ;SET OFFSET TO ZERO
WRTLOP: LDA     PAT         ;GET THE DATA PATTERN
        STA@Y   ADDR        ;WRITE IT INTO MEMORY LOC
        JSR     INCADR      ;GO INCREMENT THE ADDR POINTER
        BCC     WRTLOP      ;BRANCH IF NOT DONE
        RTS                 ;RETURN IF DONE

;ROUTINE TO READ DATA FROM MEMORY AND COMPARE IT TO THE
;PATTERN STORED IN 'PAT'.  REPORTS ERRORS ON CONSOLE DEVICE.

RDPAT:  JSR     RESADR      ;RESET POINTERS TO START OF MEMORY SEGMENT
        LDY#    0           ;SET OFFSET TO ZERO
RDLOP:  LDA@Y   ADDR        ;READ DATA OUT OF MEMORY LOC
        CMP     PAT         ;COMPARE IT TO PATTERN
        BEQ     RDCONT      ;BRANCH IF IT COMPARES OK
        JSR     PRNTER      ;*** ERROR! PRINT IT OUT ***
RDCONT: JSR     INCADR      ;POINT TO NEXT MEMORY ADDR
        BCC     RDLOP       ;BRANCH IF MORE TO CHECK
        RTS                 ;RETURN IF DONE
        
    .PAGE       ;'ERROR MESSAGE PRINT ROUTINE'

;THIS ROUTINE IS CALLED TO PRINT OUT ERROR INFORMATION.
;IT EXPECTS THE MEMORY ADDRESS TO BE IN 'ADDR', THE BAD DATA
;TO BE IN THE ACCUMULATOR, AND THE GOOD DATA TO BE IN 'PAT'.

PRNTER: STA     ACSAV       ;SAVE THE ACCUMULATOR
        TXA                 ;SAVE REGISTERS
        PHA
        TYA
        PHA
        JSR     OUTEST      ;OUTPUT THE TEST NUMBER WE ARE DOING
        LDX#    MESS5       ;PRINT TEXT
        JSR     OUTSTR
        LDA     PCNT        ;THEN PRINT THE PASS WE ARE ON
        JSR     BYTOUT
        LDX#    MESS2       ;PRINT TEXT
        JSR     OUTSTR
        LDA     ADDRH       ;NOW PRINT THE MEMORY ADDR OF THE ERROR
        JSR     BYTOUT
        LDA     ADDRL
        JSR     BYTOUT
        LDX#    MESS3       ;PRINT TEXT
        JSR     OUTSTR
        LDA     ACSAV       ;GET BAD DATA
        JSR     BYTOUT      ;PRINT IT
        LDX#    MESS4       ;PRINT TEXT
        JSR     OUTSTR
        LDA     PAT         ;PRINT GOOD DATA
        JSR     BYTOUT
        JSR     CRLF        ;ADVANCE A LINE
        JSR     STOERR      ;STORE THE ERROR INFORMATION INTO INFO TABLE
        LDA     PAUSEF      ;DOES USER WANT TO PAUSE WHEN ERROR ENCOUNTERED?
        BEQ     PRNTDN      ;BRANCH IF NOT, PRESS ON
        JSR     CONINP      ;YES, THEN WAIT FOR A CHARACTER
        CMP#    'N          ;DOES USER WANT TO TURN OFF PAUSING?
        BNE     PRNTDN      ;BRANCH IF NOT
        LDA#    0           ;YES, THEN INDICATE
        STA     PAUSEF      ;THAT WE NO LONGER PAUSE ON AN ERROR
PRNTDN: PLA                 ;RESTORE REGISTERS
        TAY
        PLA
        TAX
        LDA     ACSAV       ;RESTORE AC
        RTS                 ;AND RETURN
        
    .PAGE       ;'ROUTINE TO STORE ERROR INFO INTO MEMORY TABLE'

;THIS ROUTINE STORES UP TO 240 BYTES OF ERROR INFO INTO
;'ERRTAB' (ABOUT 40 ERROR ENTRIES).  IF THE TABLE IS FULL,
;THEN NO MORE INFO IS ADDED.

STOERR: LDX     ERRPNT      ;GET POINTER TO TABLE
        CPX#    240         ;IS TABLE FULL?
        BCS     STORET      ;BRANCH IF TABLE IS FULL
        LDA     TEST        ;STORE TEST NUMBER OF THIS TEST
        STAX    ERRTAB
        INX
        LDA     PCNT        ;STORE PASS NUMBER WE ARE ON
        STAX    ERRTAB
        INX
        LDA     ADDRH       ;NOW HIGH ORDER ADDRESS WHERE ERROR OCCURED
        STAX    ERRTAB
        INX
        LDA     ADDRL       ;NOW LOW ORDER ADDRESS WHERE ERROR OCCURED
        STAX    ERRTAB
        INX
        LDA     ACSAV       ;NOW THAT BAD DATA
        STAX    ERRTAB
        INX
        LDA     PAT         ;NOW WHAT THE DATA SHOULD HAVE BEEN
        STAX    ERRTAB
        INX
        LDA#    0           ;NOW FLAG END OF TABLE WITH A ZERO
        STAX    ERRTAB      ;FOR THE TEST NUMBER
        STX     ERRPNT      ;SAVE UPDATED POINTER
STORET: RTS                 ;AND RETURN

    .PAGE       ;'ADDRESS MANIPULATION ROUTINES'

;ROUTINE TO RESET 'ADDR' TO START OF MEMORY SEGMENT

RESADR: LDA     LOWPAG      ;MOVE PAGE NUMBER TO START AT
        STA     ADDRH       ;INTO HIGH ORDER
        LDA#    0           ;ALWAYS START AT FIRST LOC
        STA     ADDRL       ;ON THAT PAGE
        RTS                 ;RETURN

;ROUTINE TO COPY CURRENT 'ADDR' INTO 'ADDRSV'

SAVADR: LDA     ADDRL       ;MOVE CURRENT ADDRESS 'ADDR'
        STA     ADRSVL
        LDA     ADDRH
        STA     ADRSVH      ;INTO 'ADDRSV'
        RTS                 ;AND RETURN

;ROUTINE TO SEE IF ADDRESS IN 'ADDR' EQUALS ADDRESS IN 'ADDRSV'.
;RETURNS Z=0 IF NOT EQUAL, Z=1 IF EQUAL.

CHKSAV: LDA     ADDRH       ;LOOK AT HIGH ORDERS
        CMP     ADRSVH
        BNE     CHKRET      ;BRANCH IF NOT EQUAL
        LDA     ADDRL       ;HIGH ORDERS ARE EQUAL
        CMP     ADRSVL      ;ARE LOW ORDERS EQUAL?
CHKRET: RTS                 ;RETURN Z=1 IF BOTH HIGH AND LOW ORDERS ARE EQUAL

    .PAGE       ;'MORE ADDRESS MANIPULATION ROUTINES'

;ROUTINE TO INCREMENT THE ADDRESS POINTER IN 'ADDR' AND CHECK TO
;SEE IF WE HAVE REACHED THE END OF THE MEMORY SEGMENT.
;RETURNS C=1 IF WE REACHED THE END, C=0 IF NOT.

INCADR: INC     ADDRL       ;BUMP LOW ORDER
        BNE     INCRET      ;BRANCH IF WE DON'T NEED TO BUMP HIGH ORDER
        INC     ADDRH       ;BUMP HIGH ORDER ALSO
        LDA     ADDRH       ;GET IT
        CMP     HIPAG       ;HAVE WE HIT END OF MEMORY SEGMENT?
        BNE     INCRET      ;BRANCH IF NOT
        SEC                 ;YES, INDICATE WE HAVE
        RTS                 ;AND RETURN
INCRET: CLC                 ;INDICATE WE HAVE NOT REACHED END OF SEGMENT
        RTS                 ;AND RETURN

;ROUTINE TO DECREMENT THE ADDRESS POINTER IN 'ADDR'.

DECADR: DEC     ADDRL       ;DECREMENT LOW ORDER BYTE
        LDA     ADDRL       ;GET IT
        CMP#    $FF         ;IS IT TIME TO DECREMENT THE HIGH ORDER?
        BNE     DECRET      ;BRANCH IF NOT
        DEC     ADDRH       ;YES, DO IT
DECRET: RTS                 ;AND RETURN

;ROUTINE TO SET THE ADDRESS POINTER TO THE HIGHEST ADDRESS
;TO BE TESTED.  ALSO COPY THE LOWEST ADDRESS INTO 'ADDRSV'.

RESHGH: JSR     RESADR      ;SET 'ADDR' TO LOWEST ADDRESS
        JSR     SAVADR      ;COPY INTO 'ADDRSV'
        LDA     HIPAG       ;GET HIGHEST PAGE +1 TO TEST
        STA     ADDRH
        LDA#    0
        STA     ADDRL
        BEQ     DECADR      ;* PBEQ * DECREMENT AND RETURN
        
    .PAGE       ;'I-O UTILITY ROUTINES'

;ROUTINE TO OUTPUT A CHARACTER STRING FROM PAGE ZERO.
;POINTED TO BY THE X REGISTER, ENDED WITH AN ALL ZEROES BYTE.

OUTSTR: STX     TEMP        ;SAVE X REGISTER
        LDAX    $0000       ;GET NEXT CHARACTER
        BEQ     OUTRET      ;BRANCH IF THAT'S ALL
        JSR     CONOUT      ;OUTPUT IT TO CONSOLE
        LDX     TEMP        ;GET POINTER BACK
        INX                 ;POINT TO NEXT CHAR
        BNE     OUTSTR      ;AND LOOP FOR IT
OUTRET: RTS                 ;AND RETURN WHEN ALL DONE

;ROUTINE TO OUTPUT THE TEST NUMBER WE ARE DOING

OUTEST: LDX#    MESS1       ;PRINT TEXT
        JSR     OUTSTR
        LDA     TEST        ;GET THE NUMBER OF THIS TEST
                            ;* PFALL * OUTPUT IT, THEN RETURN

;ROUTINE TO OUTPUT THE BYTE IN THE ACCUMULATOR AS TWO HEX CHARACTERS.

BYTOUT: PHA                 ;SAVE BYTE
        LSRA                ;MOVE HIGH ORDER NYBBLE
        LSRA                ;INTO LOW ORDER
        LSRA
        LSRA
        TAX                 ;INTO X REGISTER
        LDAX    HEXTAB      ;CONVERT TO ASCII
        JSR     CONOUT      ;OUTPUT IT
        PLA                 ;GET BYTE BACK
        AND#    $0F         ;KEEP ONLY LOW ORDER NYBBLE
        TAX                 ;INTO X REGISTER
        LDAX    HEXTAB      ;CONVERT TO ASCII
        JMP     CONOUT      ;* PJMP * OUTPUT IT AND RETURN

;ROUTINE TO OUTPUT A CARRIAGE RETURN FOLLOWED BY A LINE FEED.

CRLF:   LDA#    %15         ;GET A CARRAIGE RETURN
        JSR     CONOUT      ;OUTPUT IT
        LDA#    %12         ;GET A LINE FEED
        JMP     CONOUT      ;* PJMP * OUTPUT IT AND RETURN

    .PAGE       ;' TABLES USED '

;TABLE TO CONVERT HEX TO ASCII

HEXTAB: .BYTE   '0
        .BYTE   '1
        .BYTE   '2
        .BYTE   '3
        .BYTE   '4
        .BYTE   '5
        .BYTE   '6
        .BYTE   '7
        .BYTE   '8
        .BYTE   '9
        .BYTE   'A
        .BYTE   'B
        .BYTE   'C
        .BYTE   'D
        .BYTE   'E
        .BYTE   'F


;TABLE OF ADDRESSES OF EACH OF THE MEMORY TESTS

        .DEF    ADRTAB = .-2  ;DEFINE BASE ADDR OF TABLE

        .WORD   MTEST1      ;TEST 1
        .WORD   MTEST2      ;TEST 2
        .WORD   MTEST3      ;TEST 3
        .WORD   MTEST4      ;TEST 4
        .WORD   MTEST5      ;TEST 5
        .WORD   MTEST6      ;TEST 6
        .WORD   MTEST7      ;TEST 7
        .WORD   MTEST8      ;TEST 8
        .WORD   0           ;SPACE FOR HACKERS
        .WORD   0
        .WORD   0
        
        .PAGE   ;'MORE TABLES'

;COMMAND TABLE CONSISTS OF THREE BYTE ENTRIES.  THE FIRST BYTE
;INDICATES WHICH TEST IS TO BE DONE.  THE SECOND BYTE INDICATES
;HOW MANY TIMES TO DO THAT TEST.  THE THIRD BYTE IS A FLAG WHICH,
;WHEN NON-ZERO,DICATES THAT WE ARE TO PAUSE AFTER AN ERROR IS
;DETECTED.  THE TABLE IS ENDED WITH A ZERO FOR THE TEST NUMBER TO DO.

CMDTAB: .BYTE   1       ;DO TEST 1
        .BYTE   50      ;FOR 50 PASSES
        .BYTE   0       ;DO NOT PAUSE ON AN ERROR
        .BYTE   2       ;DO TEST 2
        .BYTE   25      ;FOR 25 PASSES
        .BYTE   0       ;DO NOT PAUSE ON AN ERROR
        .BYTE   3       ;DO TEST 3
        .BYTE   0       ;FOR 256 PASSES
        .BYTE   0       ;DO NOT PAUSE ON AN ERROR
        .BYTE   4       ;DO TEST 4
        .BYTE   0       ;FOR 256 PASSES
        .BYTE   0       ;DO NOT PAUSE ON ERRORS
        .BYTE   7       ;DO TEST 7
        .BYTE   2       ;FOR 2 PASSES
        .BYTE   0       ;DO NOT PAUSE ON ERRORS
        .BYTE   8       ;DO TEST 8
        .BYTE   0       ;FOR 256 PASSES
        .BYTE   0       ;DO NOT PAUSE ON ERRORS
        .BYTE   5       ;DO TEST 5
        .BYTE   1       ;FOR ONE PASS
        .BYTE   1       ;PAUSE ON ERRORS
        .BYTE   0       ;END OF COMMAND LIST
        .BYTE   0       ;ADDITIONAL ROOM FOR HACKERS
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0

    .LINK   BIODEF

    .END
