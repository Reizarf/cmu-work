;   DDT - "DYNAMIC DEBUGGING TECHNIQUE"

;   A PROM-RESIDENT DEBUG MONITOR FOR THE MOS 650X MPU

;   AUTHOR: WAYNE WALL AND FRIENDS

;   ADAPTED FOR TLB SYSTEMS BY WAYNE WALL, JUNE 2020
;
;   BESIDES DDT, THIS PROM CONTAINS THE TLB BIOS ROUTINES

;"DDT" HAS BEEN UPDATED TO ALLOW SIMPLE MNEMONIC OUTPUT AND
;INPUT OF OPCODES.

;COPYRIGHT  1976,1977 BY WAYNE WALL

;A TLB SYSTEM WAS A HOMEBREW COMPUTER IN KIT FORM, DESIGNED BY 6502 GROUP
;MEMBER TOM L. BILLINGS CIRCA 1976-77.  ONE WAS RESURRECTED BY WAYNE WALL
;AND SCOT ANDERSON IN 2020.

;VERSION NUMBER (INCREMENT AND ADD COMMENT AFTER A MODIFICATION).

    ;V1: MODIFIED FROM 6502 GROUP ORIGINAL.  CRUDE TLB I/O.
    ;V2: MADE ROMABLE, ADDED TLB BIOS INTERFACE.
    ;V3: ADDED FAST LOADER VIA TLB PARALLEL PORT.
    ;V4: FIXED 'ASLA' BUG IN FAST LOADER CODE.
    ;
    ;V5: (9/11/2020) FIXED BRANCH BUG IN 'S' COMMAND DUE TO BIOS NOT
    ;    PRESERVING PROCESSOR STATUS.  ADDED VERSION NUMBER.
    ;    INITIALIZE SOME RAM LOCS ON 'RESET'.
    ;
    ;V6: (9/18/2020) ADDED CONSOLE CURSOR (CONCUR) AND CONSOLE CLEAR
    ;    SCREEN (CONCLR) ENTRY POINT TO BIOS ENTRY POINT TABLE AND TO
    ;    THE BIOS CODE.
    ;
    ;V7: (9/18/2020) MOVED BIOS DISPATCH TABLE TO $FF00 AND START DDT
    ;    IMMEDIATELY FOLLOWING SO ADDRESS OF DISPATCH TABLE IS FIXED.
    ;
    ;V8: (9/18/2020) FIXED HIGH ORDER BUG IN TLB BIOS TVPADD.
    ;
    ;V9: (9/18/2020) FIXED LOOP CONTROL BUG IN TLB BIOS TVPMUL.
    
    .DEF DDTVER = 9         ;THIS VERSION OF DDT.
    
    .PAGE
    
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

;  DDT PROMPTS WITH 'DDT>'
;  -----------------------


;  DISPLAYING MEMORY CONTENTS
;  --------------------------

;  DDT>MMMM/    ;OPENS MEMORY ADDR MMMM (LEADING ZEROES NOT NECESSARY)
;               ;AND TYPES OUT ITS CONTENTS.  THE LOCATION IS THEN
;               ;AVAILABLE FOR MODIFICATION.  TO ALTER THE CONTENTS,
;               ;SIMPLY TYPE IN A NEW VALUE IF DESIRED.  IF NO
;               ;VALUE IS TYPED, THE CURRENT VALUE IS RETAINED.
;               ;AFTER OPTIONALLY TYPING IN A NEW VALUE, THEN
;               ;TYPE ONE OF THE FOLLOWING:

;  DDT>MMMM/ XX     ;<CR> CARRIAGE RETURN CLOSES THE LOCATION,
;  DDT>             ;AND RETURNS TO COMMAND INPUT.


;  DDT>MMMM/ XX     ;<LF> CLOSES THE LOCATION, OPENS NEXT SEQUENTIAL
;  MMMM+1/ XX       ;MEMORY ADDR.


;  DDT>MMMM/ XX ^   ;'^' UP-ARROW CLOSES THE LOCATION, OPENS NEXT LOWER
;  MMMM-1/ XX       ;MEMORY ADDR.

;  ------------------------------------------------

;  DDT>/    ;SIMPLY TYPING A SLASH WILL OPEN THE LAST OPENED
;           ;ADDR, AND DISPLAY ITS CONTENTS.  THEN ANY OF THE
;           ;ABOVE OPTIONS MAY BE EXERCISED.

;  ----------------------------------------------------

;  DDT>M    ;THIS COMMAND TOGGLES THE DEFAULT OUTPUT AND INPUT
;           ;MODES BETWEEN 'HEX' AND 'MNEMONIC'.  WHEN DDT
;           ;IS 'RESET' THE DEFAULT MODE IS HEX.  IF THE USER
;           ;WANTS TO INPUT A HEX VALUE WHEN THE INPUT MODE
;           ;IS MNEMONIC, THEN HE SHOULD PRECEED THE NUMBER
;           ;WITH A '$'.

    .PAGE

;  UNCONDITIONAL JUMP (GOTO)
;  -------------------------

;  DDT>MMMMG    ;WILL TRANSFER CONTROL TO LOCATION MMMM VIA
;               ;A 'JMP' INSTRUCTION.  THIS IS THE NORMAL MECHANISM
;               ;FOR STARTING SOME OTHER PROGRAM RUNNING.

;  DDT>G    ;THIS TRANSFERS CONTROL BY JUMPING TO
;           ;AN ADDR THAT THE USER HAS PATCHED IN (USING DDT)
;           ;AT LOCATION 'GOADDR' AS HIS DEFAULT ADDR TO GO
;           ;TO WHEN HE DOES NOT SPECIFY AN ADDR.



;  BREAKPOINT MANIPULATION
;  -----------------------

;  DDT>MMMMT    ;WILL SET A DEBUG TRAP (BREAKPOINT) AT LOCATION
;               ;'MMMM'.  ONLY ONE BREAKPOINT CAN BE ACTIVE AT A
;               ;TIME.  BREAKPOINTS SHOULD BE SET ONLY
;               ;AT MEMORY ADDRESSES WHICH CONTAIN INSTRUCTION
;               ;OP CODES, OTHERWISE RESULTS WILL BE UNPREDICTABLE.
;               ;WHEN THE USER'S PROGRAM ENCOUNTERS THIS OP CODE,
;               ;A TRAP TO DDT WILL OCCUR BEFORE THE INSTRUCTION
;               ;IS EXECUTED.
;
;  T@MMMM   ;THIS MESSAGE IS TYPED TO INFORM THE USER THAT A
;  DDT>     ;TRAP AT THE SPECIFIED ADDR WAS ENCOUNTERED.
;           ;CONTROL IS RETURNED TO DDT.  WHEN THE USER IS
;           ;READY TO PROCEED FROM HIS STOPPED BREAKPOINT, HE

;  DDT>P    ;USES THE 'P' (PROCEED) COMMAND.  THIS COMMAND
;           ;CAUSES THE INSTRUCTION AT THE BREAKPOINT TO BE
;           ;EXECUTED AND CONTROL RESTORED, BUT THE BREAKPOINT
;           ;IS STILL IN EFFECT, I.E., IF ENCOUNTERED
;           ;AGAIN, PROGRAM WILL TRAP TO DDT.

;  DDT>NNP  ;SAYS PROCEED THROUGH NN (IN HEX) ENCOUNTERS OF
;           ;THE BREAKPOINT BEFORE RETURNING CONTROL TO DDT.

;           ;A NEW BREAKPOINT MAY BE SET WHILE STOPPED AT
;           ;THE CURRENT BREAKPOINT.  THE NEXT 'P' COMMAND
;           ;WILL RESUME EXECUTION AT THE BREAKPOINT WHICH
;           ;CAUSED THE TRAP, I.E., PROGRAM IS AUTOMATTICALLY
;           ;RESUMED AT PROPER POINT, WITH NEW BREAKPOINT NOW
;           ;IN EFFECT.

;  DDT>T    ;THIS CAUSES ANY BREAKPOINTS TO BE REMOVED, BUT
;           ;A 'P' COMMAND WILL PROPERLY RESUME PROGRAM FROM
;           ;WHERE IT TRAPPED.

    .PAGE

;  EXAMINING MACHINE STATUS BEFORE BREAKPOINT
;  ------------------------------------------


;  DDT>S    ;THIS COMMAND OPENS THE FIRST OF A SERIES OF
;           ;SEQUENTIAL LOCATIONS WHERE THE MACHINE STATE
;           ;BEFORE THE BREAKPOINT WAS ENCOUNTERED IS STORED.
;           ;THE LOCATIONS CONTAIN, SEQUENTIALLY:
;           ;
;           ;THE ACCUMULATOR
;           ;THE X REGISTER
;           ;THE Y REGISTER
;           ;THE STACK POINTER
;           ;THE PROCESSOR STATUS
;           ;THE OP CODE OF THE INSTR AT THE BREAKPOINT
;           ;THE LOW ORDER ADDR OF BREAKPOINT
;           ;THE HIGH ORDER ADDR OF BREAKPOINT
;           ;THE LOW ORDER ADDR OF USER'S DEFAULT 'G' ADDR
;           ;THE HIGH ORDER OF THE USER'S DEFAULT 'G' ADDR
;           ;THE LOW ORDER ADDR OF USER'S IRQ SERVICE ROUTINE
;           ;THE HIGH ORDER ADDR OF THE USER'S IRQ SERVICE ROUTINE

;  LOAD BYTES INTO MEMORY FROM EXTERNAL DEVICE
;  -------------------------------------------

;  DDT>L    ;THIS COMMAND LOADS BYTES PROVIDED BY AN EXTERNAL DEVICE.
;           ;CURRENTLY THESE BYTES ARE "TYPED" INTO THE KEYBOARD PORT
;           ;AT HIGH SPEED VIA AN EXTERNAL ARDUINO.  THE EXPECTED
;           ;FORMAT IS THE ".BIN" FORMAT PRODUCED BY SCOT ANDERSON'S
;           ;CROSS ASSEMBLER (ASM65).
;           ;
;           ;NOTHING WILL BE DISPLAYED WHILE THE LOAD IS HAPPENING.
;           ;IF THE LOAD IS SUCCESSFUL, A NEW "DDT>" PROMPT WILL APPEAR.
;           ;IF NOT SUCCESSFUL, A "?" WILL BE DISPLAYED.

;  HOW DDT HANDLES IRQ INTERRUPTS
;  ------------------------------

;DDT ESTABLISHES IT'S BREAKPOINT BY REPLACING THE OP CODE
;OF THE INSTRUCTION WITH A 00 OP CODE (BRK INSTRUCTION).  WHENEVER
;AN IRQ INTERRUPT HAPPENS, DDT FIRST LOOKS TO SEE IF IT WAS CAUSED BY
;IT'S BREAKPOINT INSTRUCTION.  IF NOT, IT DISPATCHES [VIA A  JMP (UINT)]
;VIA A LOCATION IN RAM POINTING TO THE USER'S OWN IRQ ROUTINE, AS IT IS
;ASSUMED HE KNOWS HOW TO HANDLE THE INTERRUPT.  WHEN CONTROL GETS
;TO THE USER'S ROUTINE, EVERYTHING IS THE SAME AS IF THE IRQ HAD
;GONE THERE DIRECTLY, AS DDT IS TRANSPARENT.

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    .PAGE

;*** IMPORTANT ***
;
;DON'T USE ANY PAGE ZERO LOCATIONS SO ROM CODE WILL NOT CONFLICT WITH
;AN APPLICATION PROGRAM'S PAGE ZERO USAGE.  INSTEAD, USE THE TOP OF 2K
;RAM THAT"S ON THE TLB I/O CARD.  ($E000 - $E7FF)


    .LOC    $E780       ;PLACE IN HIGH PART CPU CARD RAM, SO WE
                        ;WON'T INTERFERE WITH PAGE ZERO USAGE.

OBFPNT: .BYTE   0       ;POINTER TO MEMORY OUTPUT AREA
                        ;FOR DISASSEMBLER SEGMENT


;SEQUENTIAL SET OF LOCATIONS WHERE MACHINE STATE IS SAVED
;DURING A BREAKPOINT.


    .DEF    STATL=.     ;DEFINES WHERE MACHINE STATE IS STORED

ACSAV:  .BYTE   0       ;WHERE ACCUMULATOR IS SAVED
XSAV:   .BYTE   0       ;WHERE X REGISTER IS SAVED
YSAV:   .BYTE   0       ;WHERE Y REGISTER IS SAVED
SPSAV:  .BYTE   0       ;WHERE STACK POINTER IS SAVED
PSSAV:  .BYTE   0       ;WHERE PROCESSOR STATUS IS SAVED
                        ;* NOTE: NO NEED TO SAVE PC AS BREAKPOINT
                        ;        AS PROCEED CODE DOES NOT NEED IT.
OPBRK:  .BYTE   0       ;HOLDS OP CODE OF INSTRUCTION AT BREAKPOINT

BRKADL: .BYTE   0       ;HOLDS LOW ORDER ADDR OF BREAKPOINT
BRKADH: .BYTE   0       ;HOLDS HIGH ORDER ADDR OF BREAKPOINT


;USER'S DEFAULT PLACE TO JUMP TO ON A 'G' COMMAND WITH
;NO ADDR SPECIFIED.


GOADDR: .WORD   RESET   ;ENTER DDT UNTIL USER PATCHES
VERDDT: .BYTE   DDTVER  ;DDT VERSION NUMBER (1,2,3,...)

    .PAGE

;THIS LOCATION HOLDS THE ADDR OF THE USER PROGRAM'S IRQ SERVICE ROUTINE,
;IF HE HAS ONE. USER SHOULD DEPOSIT ADDR HERE USING DDT.

UINT:   .WORD   RESET   ;HOLDS ADDR OF USER'S IRQ SERVICE ROUTINE
                        ;INITALLY SET TO TRAP TO 'RESET' LOGIC
                
;THIS LOCATION HOLDS THE ADDR OF THE USER PROGRAM'S NMI SERVICE ROUTINE,
;IF HE HAS ONE. USER SHOULD DEPOSIT ADDR HERE USING DDT.

UNMI:   .WORD   RESET   ;HOLDS ADDR OF USER'S IRQ SERVICE ROUTINE
                        ;INITALLY SET TO TRAP TO 'RESET' LOGIC

INPL:   .BYTE   0       ;THESE TWO BYTES USED FOR TYPIN
INPH:   .BYTE   0       ;LOW AND HIGH ORDER RESPECTIVELY

MEMADL: .BYTE   0       ;LOW AND HIGH ORDER MEMORY ADDR
MEMADH: .BYTE   0       ;FOR CERTAIN OPERATIONS

OLDBRK: .WORD   0       ;HOLDS ADDR OF OLD USER BREAKPOINT

;ROM CODE WILL CONSTRUCT A SUBROUTINE HERE TO PERFORM AN STA/LDA TO/FROM
;A MEMORY ADDRESS.

DOINDR: .BYTE   0       ;WILL HOLD EITHER AN "LDA" OR "STA" OPCODE
IADDRL: .BYTE   0       ;LOW ORDER BYTE OF ADDRESS
IADDRH: .BYTE   0       ;HIGH ORDER BYTE OF ADDRESS
IRET:   .BYTE   0       ;WILL HOLD AN "RTS" OPCODE

    .DEF    PTEMP=.     ;DOUBLES AS TEMPORARY STORAGE
CHAR:   .BYTE   0       ;HOLDS CHAR ON TYPIN

OXSAV:  .BYTE   0       ;TEMPORARY TO HOLD X REGISTER

LIBYTE: .BYTE   0       ;HOLDS BYTE INPUT BY LOADER

INPFLG: .BYTE   0       ;IF = 0, THEN NO NUMBER TYPED IN
                        ;IF NOT = 0, THEN A NUMBER WAS TYPED

BRKFLG: .BYTE   0       ;IF NON ZERO, THEN WE ARE AT A BREAKPOINT

POLDB:  .BYTE   0       ;IF NON ZERO, WE MUST PROCEED FROM OLD BREAKPOINT

PRCNT:  .BYTE   0       ;USED FOR 'PROCEED' COUNTER

IBF:    .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0

OBF:    .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0
        .BYTE   0

    .PAGE

OFLAG:  .BYTE   0       ;CONTROLS IF DISASSEMBLY IS TO BE DONE.
                        ;=0 IF NOT TO BE DONE.  =$FF IF TO BE DONE.
FORMAT: .BYTE   0       ;OUTPUT FORMAT BYTE
LENGTH: .BYTE   1       ;DEFAULT LENGTH IS ONE
LMNEM:  .BYTE   0
RMNEM:  .BYTE   0

INSLOC: .BYTE   0       ;OP CODE GOES HERE
INSREL: .BYTE   0       ;SECOND BYTE GOES HERE (IF NEEDED)
        .BYTE   0       ;THIRD BYTE GOES HERE (IF NEEDED)
INLADL: .BYTE   0       ;IN-LINE LOW ORDER ADDR ON REL BRANCH
INLADH: .BYTE   0       ;IN-LINE HIGH ORDER ADDR ON REL BRANCH
JOUTL:  .BYTE   0       ;'JUMP' OP CODE HERE ON A REL BRANCH
        .BYTE   0       ;OUT-OF-LINE LOW ORDER ADDR ON REL BRANCH
        .BYTE   0       ;OUT-OF-LINE HIGH ORDER ADDR ON REL BRANCH
    
OPCTST: .BYTE   0       ;HOLDS THE TRIAL OPCODE

    .PAGE

    ;BIOS "JSR" ENTRY POINTS PLACED AT THESE HIGH ROM ADDRESSES WHICH SHOULD
    ;ALWAYS REMAIN THE SAME, SINCE APPLICATION SOFTWARE CALLS THEM!
    ;
    ;UNLESS NOTED OTHERWISE, ALL BIOS ROUTINES PRESERVE THE AC, X AND
    ;Y REGISTERS, BUT NOT THE PROCESSOR STATUS FLAGS.
    ;THEY RETURN WITH THE CARRY BIT SET IF AN ERROR OCCURED.
    
    .DEF BIOSTBL = $F800    ;(IN 2716 2KB EPROM)
    
    .LOC BIOSTBL

CONINI: JMP     KEYINI      ;* PJMP * INIT KEYBOARD

CONINO: JMP     TVOINI      ;* PJMP * INIT TV DISPLAY

CONICK: JMP     KEYCHK      ;* PJMP * KEYBOARD INPUT ROUTINE. (NO WAIT)
                            ;     7-BIT ASCII RETURNED IN AC (IF AVAILABLE)
                            ;     CARRY SET IF NO KEY AVAILABLE.
            
CONINP: JMP     KEYINP      ;* PJMP * KEYBOARD INPUT ROUTINE. (WAIT)
                            ;     7-BIT ASCII RETURNED IN AC.
                            ;     CARRY ALWAYS CLEAR TO INDICATE SUCCESS.
            
CONOUT: JMP     TVOCHR      ;* PJMP * CONSOLE DISPLAY ROUTINE.
                            ;     7-BIT ASCII PASSED IN THE AC.
                            ;     SUPPORTS CR, LF, BACKSPACE & SCROLLING.

CONCLR: JMP     TVOCLR      ;* PJMP * CONSOLE CLEAR SCREEN.
                            ;     MOVES CURSOR TO UPPER LEFT CORNER AND
                            ;     THEN CLEARS THE SCREEN.

CONCUR: JMP     TVOCUR      ;* PJMP * SET CONSOLE CURSOR POSITION.
                            ;   AC = ROW NUMBER (0,1,2,...)
                            ;   X  = COLUMN NUMBER (0,1,2,...) 
    .PAGE

    ;ALL SYMBOLIC EQUATES SHOULD BE KEPT IN THIS FILE IF POSSIBLE.

    ;DEFINE DDT'S STARTING ADDRESS

    .DEF    START=.         ;DDT STARTS RIGHT AFTER BIOS DISPATCH TABLE

    ;BASE ADDR OF HARDWARE STACK AREA

    .DEF    STACK=$0100 ;PAGE ONE ON 650X

    .PAGE
    
    ;DEFINE SOME SPECIAL ASCII CHAR CODES
    
    .DEF    CR = $0D    ;CARRIAGE RETURN
    .DEF    LF = $0A    ;LINE FEED

;DEFINE OUR ASSEMBLY ADDRESS

    .LOC    START

;HERE ON A HARDWARE 'RESET'

RESET:  SEI                 ;DISABLE INTERRUPTS
        CLD                 ;CLEAR DECIMAL MODE, IN CASE IT'S ON
        LDX#    $FF         ;INIT STACK POINTER
        TXS
        JSR     RESETI      ;INITIALIZE SOME KEY RAM LOCATIONS
        JSR     CONINI      ;INIT THE CONSOLE INPUT
        JSR     CONINO      ;INIT THE CONSOLE OUTPUT
        JSR     SETDIS      ;SET DISASSEMBLER DEFAULTS
        JSR     CLEARF      ;CLEAR BREAKPOINT FLAGS
        BEQ     PROMPT      ;ENTER MAIN COMMAND LOOP

;"MODE CHANGE" ON OUTPUT COMMAND.

MODESW: LDA     OFLAG       ;GET THE MODE CONTROL FLAG
        EOR#    $FF         ;TOGGLE IT
        STA     OFLAG       ;STORE IT BACK
        JMP     PROMPT      ;AND GET NEXT COMMAND

;'GOTO' OR 'JUMP' COMMAND

GO:     JSR     CLEARF      ;CLEAR BREAKPOINT FLAGS
        LDA     INPFLG      ;GET INPUT FLAG
        BEQ     GO1         ;BRANCH IF NO ADDR TYPED IN
        JMP@    INPL        ;JUMP TO THE ADDR USER TYPED IN
GO1:    JMP@    GOADDR      ;JUMP TO DEFAULT 'GO' ADDR

JPROC:  JMP     PROCED      ;BRANCH AID
JBRKPT: JMP     BRKPNT      ;BRANCH AID
JLOAD:  JMP     LOAD        ;BRANCH AID

    .PAGE

;COMMAND DISPATCH LOOP

QUEST:  JSR     CRLF        ;MAKE SURE WE ARE ON NEXT LINE
        LDA#    '?          ;OUTPUT A QUESTION MARK TO INDICATE
        JSR     OUTC        ;WE DON'T UNDERSTAND
PROMPT: JSR     CRLF        ;PROMPT USER WITH CRLF
        LDX#    'D          ;OUTPUT 'DDT>' AS PROMPT
        TXA                 ;COPY 'D' INTO ACCUMULATOR
        JSR OUTTWO
        LDX#    'T
        LDA#    '>
        JSR     OUTTWO
        LDY#    1           ;LOAD Y REG WITH A ONE
        STY     PRCNT       ;ASSUME PROCEED COUNT OF 1
        DEY                 ;SET Y TO ZERO
        JSR     INPWRD      ;GO INPUT AN ADDRESS FROM USER
        LDA     CHAR        ;GET TERMINATION CHAR
        CMP#    'M          ;'MODE CHANGE' COMMAND?
        BEQ     MODESW      ;BRANCH IF YES.
        CMP#    'G          ;'GOTO' COMMAND?
        BEQ     GO          ;BRANCH IF YES
        CMP#    'L          ;'LOAD' COMMAND?
        BEQ     JLOAD       ;BRANCH IF YES  
        CMP#    'P          ;'PROCEED' (FROM BREAKPOINT) COMMAND?
        BEQ     JPROC       ;BRANCH IF YES
        CMP#    'S          ;'STATUS' COMMAND?
        BEQ     STATO       ;BRANCH IF YES
        CMP#    'T          ;'TRAP' (BREAKPOINT) COMMAND?
        BEQ     JBRKPT      ;BRANCH IF YES
        CMP#    '/          ;SLASH TO OPEN THE LOCATION?
        BNE     QUEST       ;INDICATE ERROR IF NOT
                            ;YES, FALL INTO 'OPEN LOCATION' ROUTINE

    .PAGE
    
    ;EXAMINE-DEPOSIT MEMORY LOCATION(S)
    ;UPON ENTRY, "LOPEN" ASSUMES Y REGISTER IS ZERO.

        JSR     INILEN      ;RESET LENGTH COUNTER IN CASE MNEMONIC MODE
        LDA     INPFLG      ;SEE IF USER TYPED IN AN ADDRESS
        BEQ     LOPEN2      ;BRANCH IF NONE SUPPLIED, USE CURRENT
LOPEN:  LDA     INPL        ;LOAD MEM ADDR FROM INPUT AREA
        STA     MEMADL
        LDA     INPH
        STA     MEMADH
        JSR     SPACE       ;SPACE FOR LOOKS
        JSR     LIMEM       ;GET CONTENTS OF THE MEMORY ADDR
        JSR     LOPOUT      ;OUTPUT IT IN PROPER FORM
        JSR     SPACE       ;ANOTHER SPACE FOR LOOKS
        JSR     LOPINP      ;NOW AWAIT HIS TYPE-IN
        LDA     CHAR        ;GET CHAR WHICH TERMINATED TYPE-IN
        CMP#    CR          ;CARRIAGE RETURN?
        BEQ     LCLOSE      ;CLOSE THE LOCATION
        CMP#    LF          ;LINE FEED?
        BEQ     LONEXT      ;OPEN NEXT LOC
        CMP#    '^          ;UP-ARROW?
        BNE     QUEST       ;BRANCH IF TERMINATION CHAR NOT VALID
        JSR     PUTLOC      ;UPDATE CONTENTS IF NECESSARY
        DEC     MEMADL      ;BACK UP MEM ADDR
        LDA     MEMADL
        CMP#    $FF         ;GONE PAST PAGE BOUNDARY?
        BNE     LFNXT1      ;BRANCH IF NOT
        DEC     MEMADH      ;YES, THEN MUST ALSO DECREMENT HIGH ORDER
        JMP     LFNXT1      ;AND PROCEED
LONEXT: JSR     PUTLOC      ;UPDATE CONTENTS IF NECESSARY
        INC     MEMADL      ;BUMP MEM ADDR
        BNE     LONXT1      ;BRANCH IF DID NOT PASS PAGE BOUNDARY
        INC     MEMADH      ;MUST UPDATE HIGH ORDER
LONXT1: LDA#    CR          ;OUTPUT A CARRIAGE RETURN
        JSR     OUTC        ;AFTER THE LINE FEED
LOPEN2: LDA     MEMADL      ;MOVE NEW ADDR TO OUTPUT AREA
        STA     INPL
        LDA     MEMADH
        STA     INPH
        JSR     NUMOUT      ;OUTPUT IT
        LDA#    '/          ;FOLLOWED BY A SLASH FOR LOOKS
        JSR     OUTC
        BPL     LOPEN       ;UNCONDITIONALLY OPEN THIS LOCATION

    .PAGE

LCLOSE: JSR     PUTLOC      ;UPDATE CONTENTS IF NECESSARY
JPROM1: JMP     PROMPT      ;AND PROCESS NEXT COMMAND

STATO:  LDA#    >STATL      ;COPY ADDR OF WHERE WE SAVED MACHINE STATE
        STA     MEMADH
        LDA#    <STATL
        STA     MEMADL
LFNXT1: LDA#    LF          ;OUTPUT A LINE FEED TO ADVANCE
        JSR     OUTC
        JMP     LONXT1      ;AND OPEN IT FOR USER

    .PAGE

;ROUTINE TO SET A NEW BREAKPOINT, OR CLEAR AN OLD ONE

BRKPNT: LDA     BRKADL      ;IS THERE A BREAKPOINT CURRENTLY SET?
        ORA     BRKADH
        BEQ     BRKP1       ;BRANCH IF NONE
        LDA     OPBRK       ;YES, GET THE OP CODE
        JSR     SIBRK       ;RESTORE OP CODE OF INSTR
        LDA     BRKFLG      ;ARE WE PAUSED AT A BREAKPOINT?
        BEQ     BRKP1       ;BRANCH IF NOT
        LDA     POLDB       ;HAVE WE ALREADY SAVED THE OLD BREAK ADDR?
        BNE     BRKP1       ;BRANCH IF YES
        LDA#    $DF         ;GET MASK
        BIT     OPBRK       ;WAS OLD INSTRUCTION 'BRK' OR 'JSR'?
        BNE     BRKPC       ;BRANCH IF NOT
        PLA                 ;YES, THEN POP OFF TWO EXTRA ITEMS
        PLA                 ;ON STACK
BRKPC:  INC     POLDB       ;NO, BUT INDICATE WE HAVE NOW
        LDA     BRKADL      ;NOW SAVE ADDR OF OLD BREAKPOINT
        STA     OLDBRK
        LDA     BRKADH      ;FOR LATER DISPATCH
        STA     OLDBRK+1
BRKP1:  LDA     INPFLG      ;DID USER GIVE NEW BREAKPOINT ADDR?
        BEQ     BRKP2       ;BRANCH IF NOT
        LDA     INPL        ;YES, LOAD THE NEW ADDR
        STA     BRKADL      ;INTO BREAKPOINT ADDR
        LDA     INPH
        STA     BRKADH
        JSR     LIBRK       ;GET THE OP CODE
        STA     OPBRK       ;STORE AWAY
        TYA                 ;GET A ZERO
        JSR     SIBRK       ;SAVE 'BRK' IN LOCATION
BRKRET: BEQ     JPROM1      ;AND GET NEXT COMMAND
BRKP2:  STA     OPBRK       ;CLEAR ANY BREAKPOINTS
        STA     BRKADL
        STA     BRKADH
        BEQ     BRKRET      ;UNCONDITIONAL RETURN

    .PAGE

;WE COME HERE IF THIS IRQ WAS CAUSED BY OUR BREAKPOINT

OURBRK: SEI                 ;DISABLE INTERRUPT FOR SAFETY
        STY     YSAV        ;SAVE CONTENTS OF Y REGISTER
        PLA                 ;GET PROCESSOR STATUS BEFORE 'BRK'
        STA     PSSAV       ;SAVE IT
        TSX                 ;GET STACK POINTER
        INX                 ;ADD IN 2
        INX
        LDA#    $DF         ;GET MASK
        BIT     OPBRK       ;IS INSTRUCTION THAT GOES HERE 'BRK' OR 'JSR'?
        BEQ     OURBC       ;YES, KEEP PC ON STACK, BUT LIE TO USER
        PLA                 ;NO, THEN THROW PC AWAY
        PLA
OURBC:  STX     SPSAV       ;AND SAVE SO USER CAN SEE IT
        LDY#    0           ;SET Y TO ZERO
        DEC     PRCNT       ;DECREMENT PASS COUNT
        BNE     PROCC       ;FAKE A 'PROCEED' IF NOT DONE YET.
        INY                 ;INDICATE WE ARE STOPPED AT A BREAKPOINT
        STY     BRKFLG
        LDA     BRKADL      ;MOVE BREAK ADDR TO OUTPUT AREA
        STA     INPL
        LDA     BRKADH
        STA     INPH
        JSR     CRLF        ;ADVANCE A LINE
        LDX#    'T          ;OUTPUT 'T@'
        LDA#    '@
        JSR     OUTTWO
        JSR     NUMOUT      ;THEN THE ADDR OF THE 'BRK'
        JMP     PROMPT      ;JUMP BACK TO COMMAND LOOP

    .PAGE

;WE JUMP HERE ON AN IRQ FLAVOR INTERRUPT

IRQINT: CLD                 ;CLEAR DECIMAL MODE IN CASE USER HAS IT SET
        STA ACSAV           ;SAVE THE ACCUMULATOR CONTENTS
        PLA                 ;GET PROCESSOR STATUS
        PHA                 ;SAVE BACK AGAIN
        AND#    $10         ;WAS IRQ CAUSED BY A 'BRK' INSTRUCTION?
        BEQ     NOTBRK      ;BRANCH IF NOT
        STX     XSAV        ;SAVE X REGISTER
        TSX                 ;GET STACK POINTER INTO X
        LDAX    STACK+2     ;GET PCL AFTER 'BRK'
        CLC                 ;SET UP FOR ADC
        ADC#    $FE         ;MUST SUBTRACT 2 TO GET ADDR OF 'BRK'
        EOR     BRKADL      ;IS THIS DDT'S BRK INSTRUCTION?
        BNE     NOTUS       ;BRANCH IF NOT
        LDAX    STACK+3     ;MAYBE, GET HIGH ORDER
        ADC#    $FF         ;ADD IN CARRY
        EOR     BRKADH      ;ARE HIGH ORDER'S ALSO EQUAL?
        BEQ     OURBRK      ;BRANCH IF THIS IS DDT'S 'BRK'
NOTUS:  LDX     XSAV        ;RESTORE X REGISTER CONTENTS
NOTBRK: LDA     ACSAV       ;RESTORE ACCUMULATOR CONTENTS
        JMP@    UINT        ;AND JUMP TO USER'S IRQ ROUTINE
                            ;AS IT IS ASSUMED HE WILL KNOW WHAT
                            ;TO DO WITH THIS INTERRUPT

    .PAGE

;THIS CODE ALLOWS A TRANSPARENT PROCEED FROM THE 'BRK' INSTRUCTION
;BY ACTUALLY EXECUTING THE INSTRUCTION OUT OF LINE.  IT TAKES SOME
;SLEIGHT OF HAND TO DO THIS, SO READ THIS CODE CAREFULLY!

PROCED: LDA     INPFLG      ;DID USER GIVE A NUMBER
        BEQ     PROC1       ;NO, THEN ASSUME ONE
        LDX     INPL        ;YES, THEN GET LOW ORDER (1-256)
        STX     PRCNT       ;SAVE IN COUNTER
PROC1:  LDA     BRKFLG      ;ARE WE STOPPED AT A BREAKPOINT?
        BNE     PROC2       ;BRANCH IF YES
        JMP     QUEST       ;INDICATE ERROR IF NOT
PROC2:  STY     BRKFLG      ;INDICATE NOT STOPPED ANYMORE
        LDA     POLDB       ;DO WE PROCEED FROM OLD BREAKPOINT?
        BEQ     PROCC       ;BRANCH IF NOT
        STY     POLDB       ;YES, BUT INDICATE WE DON'T HAVE TO ANYMORE
        JSR     REST        ;RESTORE STATE OF MACHINE
        JMP@    OLDBRK      ;NOW JUMP BACK IN-LINE AT OLD BREAK ADDR
PROCC:  LDA     OPBRK       ;GET OP CODE OF INSTRUCTION TO EXECUTE
        BEQ     PRBRK       ;BRANCH IF IT WAS A 'BRK' INSTR
        STA     INSLOC      ;STORE IT OUT OF LINE FOR LATER EXECUTION
        BIT     BIT3        ;START THE MAGIC OP CODE DECODING!
        BEQ     HALFOP      ;SPLIT OP CODE IN HALF
        BIT     BIT2        ;BIT 3=1
        BNE     O3BYTE      ;AND BIT 2=1 MEANS THREE BYTE INSTR
        BIT     BIT0        ;BIT 2=0
        BEQ     O1BYTE      ;AND BIT 0=0 MEANS ONE BYTE INSTR
        BIT     BIT4        ;BIT 0=1
        BEQ     O2BYTE      ;AND BIT 4=0 MEANS 2 BYTE INSTR
        BNE     O3BYTE      ;OTHERWISE, THREE BYTE INSTR
HALFOP: BIT     BIT012      ;BIT 3=0
        BNE     O2BYTE      ;AND EITHER 0,1,2 = 1, THEN 2 BYTE
        BIT     BIT4        ;BITS 0,1,2 ALL =0
        BNE     O2BREL      ;AND BIT 4=1 MEANS 2 BYTE RELATIVE BRANCH
        BIT     BIT7        ;BIT 4=0
        BNE     O2BYTE      ;AND BIT 7=1, MEANS TWO BYTE INSTR
        CMP#    $20         ;IS IT A 'JSR' INSTRUCTION?
        BNE     O1BYTE      ;ONE BYTE IF NOT
        LDA#    $4C         ;REPLACE 'JSR' OP CODE WITH A 'JMP'
        STA     INSLOC
O3BYTE: INY                 ;HERE IF INSTRUCTION IS 3 BYTES LONG
O2BYTE: INY                 ;HERE IF INSTRUCTION IS 2 BYTES LONG
O1BYTE: INY                 ;HERE IF INSTRUCTION IS 1 BYTE LONG
        JSR SETINS          ;GO SET UP THE INSTRUCTION OUT OF LINE
DOPROC: JSR REST            ;RESTORE STATE OF MACHINE
        JMP INSLOC          ;JUMP TO CODE TO DO THE INSTRUCTION
                            ;AND RETURN IN-LINE IF NECESSARY.

    .PAGE

;ROUTINE TO PROCEED FROM A 'BRK' INSTRUCTION

PRBRK:  JSR REST            ;RESTORE STATE OF MACHINE
        PHP                 ;PUSH PROCESSOR STATUS ON STACK
        JMP@    UINT        ;GO TO USER SUPPLIED HANDLER

;HERE IF INSTRUCTION IS A RELATIVE BRANCH

O2BREL: LDY#    2           ;INDICATE TWO BYTE INSTRUCTION
        JSR     SETINS      ;SET UP THE IN-LINE AS ALWAYS
        LDA#    $4C         ;GET 'JMP' OP CODE
        STA     JOUTL       ;SAVE IT FOR OUT-OF-LINE PATH
        LDX#    $FF         ;GET MINUS 1
        LDA     INSREL      ;GET REL OFFSET
        BMI     O2BR1       ;BRANCH IF NEG OFFSET
        INX                 ;FORM ZERO
O2BR1:  STX     PTEMP       ;STORE PROPER HIGH ORDER OFFSET
        CLC                 ;SET UP FOR ADC
        LDA     INLADL      ;GET LOW ORDER IN-LINE ADDR
        ADC     INSREL      ;ADD IN RELATIVE OFFSET
        STA     JOUTL+1     ;THAT BECOMES OUT-OF-LINE ADDR TO JUMP TO
        LDA     INLADH      ;NOW HIGH ORDER ADDR
        ADC     PTEMP       ;ADD IN HIGH ORDER OFFSET
        STA     JOUTL+2     ;STORE AWAY FOR OUT-OF-LINE JUMP
        LDA#    $03         ;NOW REL OFFSET IS A CONSTANT
        STA     INSREL      ;UPDATE IT
        BNE     DOPROC      ;AND NOW GO EXECUTE THE INSTRUCTION

    .PAGE

;UPON ENTRY, THE Y REGISTER CONTAINS THE NUMBER OF BYTES IN THE
;INSTRUCTION.

SETINS: STY     PTEMP       ;SAVE NUMBER OF BYTES IN INSTRUCTION
        LDA#    $4C         ;GET 'JMP' OP CODE
        STAY    INSLOC      ;STORE AFTER OUT-OF-LINE INSTRUCTION
        INY                 ;POINT TO WHERE LOW ORDER IN-LINE ADDR GOES
        CLC                 ;SET UP FOR ADC
        LDA     BRKADL      ;GET ADDR OF WHERE OP CODE CAME FROM
        ADC     PTEMP       ;ADD IN LENGTH OF INSTRUCTION TO FIND
        STAY    INSLOC      ;WHERE TO JUMP BACK AFTER INSTRUCTION IS
        INY                 ;EXECUTED
        LDA     BRKADH      ;GET HIGH ORDER
        ADC#    0           ;ADD IN CARRY
        STAY    INSLOC      ;STORE AS HIGH ORDER TO 'JMP' INSTR
        LDY     PTEMP       ;GET NUMBER OF BYTES IN INSTR
        DEY                 ;-1 = NUMBER OF EXTRA BYTES TO MOVE
        BEQ     ENDINS      ;BRANCH IF NONE TO MOVE (1 BYTE INSTR)
MOVINS: JSR     LIBRK       ;GET BYTE TO MOVE
        STAY    INSLOC      ;STORE OUT-OF-LINE
        DEY                 ;ALL DONE?
        BNE MOVINS          ;BRANCH IF MORE
ENDINS: RTS                 ;AND RETURN

    .PAGE

;THIS ROUTINE WILL DISASSEMBLE THE BYTE IN THE ACCUMULATOR IF
;THE OUTPUT FLAG 'OFLAG' IS NON-ZERO.

LOPOUT: PHA                 ;SAVE BYTE ON STACK
        JSR     BYTOUT      ;ALWAYS OUTPUT THE BYTE IN HEX
        PLA                 ;RESTORE THE BYTE
        LDX     OFLAG       ;DO WE DISASSEMBLE?
        BEQ     LOPRET      ;BRANCH IF WE DO NOT
        DEC     LENGTH      ;YES, BUT IS THIS INSTRUCTION OVER?
        BEQ     LOPDIS      ;BRANCH IF YES, THEN WE DISASSEMBLE
LOPRET: RTS                 ;OTHERWISE RETURN
LOPDIS: PHA                 ;SAVE THE OPCODE ACCROSS CALL
        JSR     DISASM      ;CALL THE DISASSEMBLER
        PLA                 ;RESTORE THE OPCODE
        RTS                 ;AND RETURN

;ROUTINE TO SETUP DEFAULTS FOR DISASSEMBLER ROUTINE

SETDIS: LDA#    0           ;GET A ZERO
        STA     OFLAG       ;SET OUTPUT TO HEX MODE
INILEN: LDA#    1           ;GET A ONE
        STA     LENGTH      ;INIT THE LENGTH OF INSTRUCTION
        RTS                 ;AND RETURN

    .PAGE

;ROUTINE TO DISASSEMBLE THE OPCODE IN THE ACCUMULATOR
;ROUTINE IS FROM BAUM & WOZNIAK, MODIFIED BY JOHN LOGSDON.
;HACKED FURTHER BY WAYNE WALL.

DISASM: LDX#    0           ;RESET POINTER TO MEMORY AREA IN CASE
        STX     OBFPNT      ;WE WRITE IN IT.
        TAY                 ;SAVE OPCODE IN Y REGISTER
        LSRA                ;EVEN/ODD TEST
        BCC     IEVEN       ;BRANCH IF OPCODE IS EVEN
        LSRA                ;TEST BIT 1
        BCS     ERR         ;XXXXXX11 INSTR IS INVALID.
        CMP#    $22         ;SPECIAL TEST
        BEQ     ERR         ;10001001 INSTR IS INVALID.
        AND#    7           ;MASK 3 BITS FOR ADDRESSING MODE &
        ORA#    $80         ;ADD IN INDEXING OFFSET.
IEVEN:  LSRA                ;LSB INTO CARRY FOR
        TAX                 ;LEFT/RIGHT TEST BELOW
        LDAX    MODE        ;INDEX INTO ADDRESSING MODE TABLE
        BCS     RTMODE      ;IF CARRY SET USE LSD FOR
        LSRA                ;PRINT FORMAT INDEX
        LSRA
        LSRA                ;IF CARRY CLEAR, USE MSD
        LSRA
RTMODE: AND#    $F          ;MASK FOR 4-BIT INDEX
        BNE     GETFMT      ;ZERO FOR INVALID OPCODES
ERR:    LDY#    $80         ;SUBSTITUE $80 FOR INVALID OPCODES.
        LDA#    0           ;SET PRINT FORMAT INDEX TO ZERO
GETFMT: TAX                 ;INDEX INTO PRINT FORMAT TABLE
        LDAX    MODE2
        STA     FORMAT      ;SAVE FOR ADDR FIELD FORMAT
        LDAX    MODE3       ;INDEX INTO INSTRUCTION LENGTH TABLE
        STA     LENGTH      ;STORE LENGTH FOR LATER
        JSR     SPACEX      ;OUTPUT A SPACE FOR LOOKS
        TYA                 ;GET THE OPCODE AGAIN
        AND#    $8F         ;MASK IT FOR 1XXX1010 TEST
        TAX                 ;SAVE IT
        TYA                 ;GET OPCODE AGAIN
        LDY#    3
        CPX#    $8A
        BEQ     MNNDX3
                            ;MORE ON NEXT PAGE

    .PAGE

MNNDX1: LSRA
        BCC     MNNDX3      ;FORM INDEX INTO MNEMONIC TABLE.
        LSRA
MNNDX2: LSRA                ;1XXX1010 -> 00101XXX
        ORA#    $20         ;XXXYYY01 -> 00111XXX
        DEY                 ;XXXYYY10 -> 00110XXX
        BNE     MNNDX2      ;XXXYY100 -> 00100XXX
        INY                 ;XXXXX000 -> 000XXXXX
MNNDX3: DEY
        BNE     MNNDX1
        TAY                 ;STORE OFFSET TO Y
        LDAY    MNEML       ;GET 3 CHAR MNEMONIC
        STA     LMNEM       ;SAVE IT
        LDAY    MNEMR       ; (PACKED IN 2 BYTES)
        STA     RMNEM       ;SAVE SECOND BYTE
        LDX#    3           ;LOAD COUNTER
PRMN1:  LDA#    0
        LDY#    5
PRMN2:  ASL     RMNEM
        ROL     LMNEM       ;SHIFT 5 BITS OF CHAR INTO ACCUMUALTOR
        ROLA                ;(CLEARS CARRY)
        DEY
        BNE     PRMN2
        ADC#    $BF         ;ADD IN "?" OFFSET
        JSR     OUTCX       ;OUTPUT THE CHARACTER
        DEX                 ;DONE ALL 3 YET?
        BNE     PRMN1       ;BRANCH IF NOT
        LDY     FORMAT      ;GET THE FORMAT OFFSET
FMTLOP: LDAY    MODLST      ;GET A CHARACTER
        BEQ     DONE        ;ALL DONE IF ZERO
        JSR     OUTCX       ;OUTPUT THIS CHARACTER
        INY                 ;POINT TO NEXT ONE
        BPL     FMTLOP      ;AND LOOP FOR NEXT ONE
DONE:   TAY                 ;RETURN ZERO IN Y REG
        RTS                 ;AND RETURN

    .PAGE
    
;LOAD BYTES FROM EXTERNAL DEVICE
    
LOAD:   JSR     CONINP      ;GET A CHARACTER FROM KEYBOARD PORT.
        CMP#    '*          ;IGNORE ANYTHING BEFORE THE FIRST ADDRESS
        BNE     LOAD        ;DESIGNATOR.
LNEWAD: JSR     LDADDR      ;FETCH NEW ADDRESS INTO MEMADL/MEMADH
        BCC     LDDATA      ;NOW LOAD DATA BYTES
LDERR:  JMP     QUEST       ;* ERROR! *
LDDATA: JSR     LDBYTE      ;LOAD A DATA BYTE
        BCC     LDSTOD      ;BRANCH IF SUCCESSFUL
        LDA     CHAR        ;GET NON HEX CHARACTER
        CMP#    '*          ;IS IT AN ADDRESS DESIGNATOR?
        BEQ     LNEWAD      ;BRANCH IF YES.
        CMP#    CR          ;IS IT A CARRIAGE RETURN?
        BNE     LDERR       ;IF NOT, THEN AN ERROR HAS OCCURRED.
        JMP     PROMPT      ;YES, LOAD WAS SUCCESSFUL.
LDSTOD: JSR     SIMEM       ;STORE THE DATA BYTE
        INC     MEMADL      ;INCREMENT MEMORY ADDRESS
        BNE     LDNEXT
        INC     MEMADH
LDNEXT: JMP     LDDATA      ;LOOP BACK TO LOAD ANOTHER DATA BYTE        
    
;LOAD TWO BYTES AND STORE THEM IN MEMADL AND MEMADH.
;IF SUCCESSFUL, RETURNS WITH CARRY BIT CLEAR.
    
LDADDR: JSR     LDBYTE      ;LOAD HIGH ORDER ADDRESS
        BCS     LADRET      ;BRANCH IF ERROR
        STA     MEMADH      ;STORE FOR LATER USE
        JSR     LDBYTE      ;LOAD LOW ORDER ADDRESS
        BCS     LADRET      ;BRANCH IF ERROR
        STA     MEMADL      ;STORE FOR LATER USE
        CLC                 ;INDICATE SUCCESS
LADRET: RTS
    
    ;LOAD TWO HEX DIGITS REPRESENTING ONE BYTE.
    ;IF SUCCESSFUL, RETURNS WITH CARRY BIT CLEAR
    ;AND VALUE LOADED IN THE AC.
    
LDBYTE: JSR     INPHEX      ;LOAD NEXT HEX DIGIT
        BCS     LDBRET      ;BRANCH IF NOT A HEX DIGIT
        ASLA                ;PLACE HEX DIGIT IN HIGH ORDER NYBBLE
        ASLA
        ASLA
        ASLA
        STA     LIBYTE      ;REMEMBER VALUE
        JSR     INPHEX      ;LOAD NEXT HEX DIGIT
        BCS     LDBRET      ;BRANCH IF NOT A HEX DIGIT
        ORA     LIBYTE      ;UPDATE VALUE LOADED
        CLC                 ;INDICATE SUCCESS
LDBRET: RTS

;INPUT ONE HEX DIGIT.
;IF SUCCESSFUL, RETURNS WITH CARRY CLEAR AND HEX VALUE IN AC.
;IF NOT SUCCESSFUL, RETURNS WITH CARRY SET AND CHARACTER IN "CHAR".

INPHEX: JSR     CONINP      ;GET INPUT CHAR
INPHX:  STA     CHAR        ;SAVE CHAR FOR LATER
        CMP#    '0          ;LESS THAN ZERO?
        BMI     INPNHX      ;BRANCH IF YES, NOT HEX
        CMP#    '9 + 1      ;GREATER THAN '9'?
        BPL     INPCK1      ;BRANCH IF YES, MUST CHECK FURTHER
        AND#    $0F         ;FORM BINARY VALUE
        CLC                 ;INDICATE SUCCESS
        RTS
INPCK1: CMP#    'A          ;LESS THAN 'A'?
        BMI     INPNHX      ;BRANCH IF YES, NOT HEX
        CMP#    'F + 1      ;GREATER THAN 'F'?
        BPL     INPNHX      ;BRANCH IF YES, NOT HEX
        AND#    $0F         ;KEEP LOW ORDER 4-BITS
        CLC                 ;PREPARE FOR ADC
        ADC#    9           ;FORM BINARY VALUE
        RTS                 ;RETURN SUCCESS (CARRY BIT WILL BE CLEAR)
INPNHX: SEC                 ;INDICATE FAILURE
        RTS

    .PAGE

;ROUTINE TO INPUT A HEX NUMBER. IT IS NOT NECCESSARY TO TYPE
;LEADING ZEROES.  UPON ENTRY, "INPWRD" ASSUMES Y REGISTER IS ZERO.

INPWRD: JSR     INPINI      ;INIT INPUT VALUES
INPLOP: JSR     INPCHK      ;GO INPUT A CHAR, CHECK FOR A HEX DIGIT
        BCS     NOTHEX      ;TERMINATE IF NOT HEX
        INC     INPFLG      ;COUNT THIS DIGIT
        LDX#    4           ;INIT SHIFT COUNTER
SHIFTI: ASL     INPL        ;SHIFT 16 BITS LEFT
        ROL     INPH
        DEX                 ;DONE FOUR TIMES YET
        BNE     SHIFTI      ;BRANCH IF NOT
        ORA     INPL        ;PUT THIS DIGIT INTO NUMBER
        STA     INPL
        JMP     INPLOP      ;AND GO PROCESS NEXT DIGIT
NOTHEX: RTS                 ;RETURN ON NON-HEX CHAR

INPINI: STY     INPL        ;ASSUME NUMBER IS ZERO
        STY     INPH        ;CURRENTLY TWO BYTES MAX
        STY     INPFLG      ;ASSUME NO INPUT YET
        RTS                 ;AND RETURN

INPCHK: JSR     CONINP      ;GET CHARACTER FROM CONSOLE
        JSR     OUTC        ;ECHO THE CHARACTER ON CONSOLE
        CMP#    'a          ;IS IT LESS THAN 'a'?
        BMI     INPNLC      ;BRANCH IF YES.  CHAR IS NOT LOWER CASE ALPHABETIC
        CMP#    'z          ;IS IT GREATER THAN 'z'?
        BPL     INPNLC      ;BRANCH IF YES.  CHAR IS NOT LOWER CASE ALPHABETIC
        EOR#    'a - 'A     ;CONVERT LOWER CASE ALPHA TO UPPER CASE ALPHA
INPNLC: JMP     INPHX       ;* PJMP * CHECK FOR HEX DIGIT AND RETURN

        
    .PAGE

;ROUTINE TO ACCEPT INPUT IN EITHER HEX OR MNEMONIC FORM.

LOPINP: LDA     OFLAG       ;ARE WE IN MNEMONIC MODE?
        BEQ     INPWRD      ;* PBEQ *  NO, THEN ALLOW ONLY HEX INPUT
        JSR     INPINI      ;INIT INPUT VALUES
        LDX#    0           ;INIT POINTER TO MEMORY INPUT AREA
        STX     OPCTST      ;AND START AT OPCODE ZERO IF MNEMONIC IS INPUT
LOPI1:  JSR     INPCHK      ;GET A CHAR FROM INPUT DEVICE
        CMP#    '$          ;DOLLAR SIGN?
        BEQ     INPWRD      ;* PBEQ * YES, THEN HEX INPUT
        CMP#    CR          ;CARRIAGE RETURN?
        BEQ     LOPEND      ;BRANCH IF SO
        CMP#    LF          ;LINE FEED?
        BEQ     LOPEND      ;BRANCH IF SO
        CMP#    '^          ;UPARROW?
        BEQ     LOPEND      ;BRANCH IF SO
        CMP#    '           ;SPACE?
        BEQ     LOPI1       ;YES, THEN IGNORE IT
        STAX    IBF         ;STORE CHARACTER INPUT INTO BUFFER
        INX                 ;POINT TO NEXT LOC IN BUFFER
        BNE     LOPI1       ;AND GO CHECK THIS CHARACTER
LOPEND: TXA                 ;GET POINTER TO INPUT STRING
        BEQ     LOPIRT      ;BRANCH IF NO INPUT
        LDA#    0           ;FLAG THE END OF THE INPUT
        STAX    IBF
        STA     OFLAG       ;FAKE OUT DISASSEMBLER ROUTINE BY INDICATING
                            ;THAT WE ARE NOT IN MNEMONIC MODE
                            ;SO THAT IT WILL OUTPUT TO MEMORY BUFFER.
CNXTOP: LDA     OPCTST      ;GET OPCODE TO CHECK
        JSR     DISASM      ;DISASSEMBLE IT INTO MEMORY
        JSR     COMPAR      ;NOW CHECK TO SEE IF THIS ONE IS THE ONE
        BCC     GOTOPC      ;USER TYPED IN.  BRANCH IF THEY MATCH
        INC     OPCTST      ;NO MATCH, TRY NEXT POSSIBLE OPCODE
        BNE     CNXTOP      ;UNTIL WE HAVE TRIES ALL 256!
        LDA#    $FF         ;NO MATCH.  INDICATE WE ARE BACK IN MNEMONIC MODE
        STA     OFLAG
        STA     CHAR        ;STORE BUM TERMINATOR SO WE BOMB OUT
        RTS                 ;AND RETURN
GOTOPC: LDA#    $FF         ;INDICATE WE ARE IN MNEMONIC MODE AGAIN
        STA     OFLAG
        STA     INPFLG      ;AND INDICATE THERE WAS INPUT
        LDA     OPCTST      ;GET THE OPCODE THAT MATCHED
        STA     INPL        ;STORE IT AS THE INPUT VALUE
LOPIRT: RTS                 ;AND RETURN

    .PAGE

    ;ROUTINE TO COMPARE THE TWO STRINGS IN 'IBF' AND 'OBF'.
    ;RETURNS WITH C=0 IF THEY ARE IDENTICAL, C=1 IF DIFFERENT.

COMPAR: LDA#    0           ;GET A ZERO
        LDX     OBFPNT      ;GET POINTER TO 'OBF'
        STAX    OBF         ;TERMINATE STRING WITH A ZERO
        TAX                 ;RESET STRING INDEX TO ZERO
COMLOP: LDAX    OBF         ;GET A CHAR FROM 'OBF'
        BEQ     DONCHK      ;BRANCH IF END OF STRING
        STA     OBFPNT      ;TEMPORARILY SAVE IN OBFPNT
        LDAX    IBF         ;GET A CHAR FORM 'IBF'
        BEQ     NOMAT       ;IF END OF STRING, NO MATCH
        CMP     OBFPNT      ;ARE THE CHARACTERS THE SAME?
        BNE     NOMAT       ;IF NOT, THEN NO MATCH POSSIBLE
        INX                 ;YES, POINT TO NEXT CHAR POSITION
        BNE     COMLOP      ;UNCONDITIONALLY CHECK NEXT CHARACTERS
NOMAT:  SEC                 ;INIDCATE NO MATCH
        RTS
DONCHK: LDAX    IBF         ;ARE WE ALSO AT END OF 'IBF' STRING?
        BNE     NOMAT       ;NO, THEN THEY ARE NOT THE SAME
        CLC                 ;INDICATE STRINGS ARE THE SAME
        RTS                 ;AND RETURN

    .PAGE

;ROUTINES TO OUTPUT CHARACTERS AND NUMBERS

;OUTPUT THE NUMBER IN INPH,INPL

NUMOUT: LDA INPH            ;GET HIGH ORDER
        JSR BYTOUT          ;OUTPUT IT
LOWOUT: LDA INPL            ;GET LOW ORDER
                            ;* PFALL INTO BYTOUT *

;ROUTINE TO OUTPUT THE BYTE IN THE ACCUMULATOR

BYTOUT: PHA                 ;SAVE BYTE
        LSRA                ;GET HIGH NIBBLE
        LSRA
        LSRA
        LSRA
        JSR     ASCII       ;MAKE HEX DIGIT ASCII CHAR
        TAX                 ;SAVE FOR OUTPUT
        PLA                 ;GET BYTE BACK
        AND#    %17         ;ISOLATE LOW ORDER NIBBLE
        JSR     ASCII       ;MAKE HEX DIGIT ASCII CHAR
                            ;* PFALL INTO 'OUTTWO' *

;ROUTINE TO OUTPUT CHAR IN X, THEN A

OUTTWO: PHA                 ;SAVE CHAR IN ACCUMULATOR
        TXA                 ;GET CHAR IN X
        JSR OUTC            ;OUTPUT IT
OUTC1:  PLA                 ;GET SECOND CHAR
OUTC:   JMP CONOUT          ;* PJMP * OUTPUT CHARACTER ON CONSOLE

;ODDS AND ENDS

CRLF:   LDX#    CR          ;CARRIAGE RETURN
        LDA#    LF          ;LINE FEED
        BPL     OUTTWO      ;* PBPL * CALL OUTTWO ROUTINE

SPACE:  LDA#    '           ;LOAD A SPACE
        BPL OUTC            ;* PBPL * CALL OUTPUT ROUTINE

    .PAGE

;MAKE HEX DIGIT IN THE AC AN ASCII CHARACTER

ASCII:  CLC                 ;PREPARE FOR ADD
        ADC#    %60         ;ADD 60 OCTAL
        CMP#    %72         ;IS DIGIT 0-9?
        BCC     ASCRET      ;BRANCH IF IT IS, IT'S CONVERTED
        ADC#    6           ;ADD 6 PLUS CARRY = 7, FORMS ASCII A-F
ASCRET: RTS                 ;RETURN

;ROUTINE TO CLEAR BREAKPOINT FLAGS

CLEARF: LDA#    0           ;INDICATE THAT
        STA     BRKFLG      ;WE ARE NOT STOPPED AT A BREAKPOINT
        STA     POLDB       ;AND WE DON'T HAVE TO PROCEED FROM AN
        RTS                 ;OLD BREAKPOINT.

;ROUTINE TO UPDATE CONTENTS OF OPEN MEMORY LOCATION

PUTLOC: LDA     INPFLG      ;DID USER TYPE IN A NEW VALUE
        BEQ     PUTRET      ;BRANCH IF NOT
        LDA     INPL        ;GET THE NEW VALUE
        JSR     SIMEM       ;PUT IT IN THE LOC
PUTRET: RTS                 ;AND RETURN

    .PAGE

;ROUTINE TO RESTORE STATE OF MACHINE

REST:   LDX     XSAV        ;RESTORE X REGISTER
        LDY     YSAV        ;RESTORE Y REGISTER
        LDA     PSSAV       ;LOAD AC WITH PROCESSOR STATUS
        PHA                 ;SAVE IT ON STACK
        LDA     ACSAV       ;RESTORE THE AC
        PLP                 ;NOW RESTORE THE PROCESSOR STATUS
        RTS                 ;AND RETURN

SPACEX: LDA#    '           ;GET A SPACE, * PFALL * INTO OUTCX
OUTCX:  AND#    %177        ;KEEP ONLY 7-BITS
        PHA                 ;SAVE CHAR TO BE OUTPUT ON STACK
        LDA     OFLAG       ;CHECK MNEMONIC FLAG
        BNE     OUTC1       ;* PBNE * OUTPUT TO DEVICE IF MNEMONIC MODE
        PLA                 ;GET THE CHAR BACK
        CMP#    '           ;SPACE?
        BEQ     OUTXRT      ;DON'T OUTPUT TO STRING IF IT'S A SPACE
        STX     OXSAV       ;SAVE X REG AS IT GETS DESTROYED
        LDX     OBFPNT      ;GET POINTER TO STRING
        STAX    OBF         ;STORE CHAR INTO STRING
        INC     OBFPNT      ;POINT TO NEXT STRING POSITION
        LDX     OXSAV       ;RESTORE X REGISTER
OUTXRT: RTS                 ;AND RETURN

;ROUTINE TO INITIALIZE SOME RAM LOCATIONS WHEN A 'RESET' OCCURS.

RESETI: LDA#    <RESET      ;STORE LOW ORDER ADDR OF 'RESET' ENTRY POINT.
        STA     GOADDR
        STA     UINT
        STA     UNMI
        LDA#    >RESET      ;STORE HIGH ORDER ADDR OF 'RESET' ENTRY POINT.
        STA     GOADDR+1
        STA     UINT+1
        STA     UNMI+1
        LDA#    DDTVER      ;STORE DDT VERSION SO USER CAN EASILY EXAMINE IT.
        STA     VERDDT        
        RTS

    .PAGE
    
;THIS ROM CODE CAN'T USE ANY PAGE ZERO LOCATIONS.  THE ONLY WAY THE 6502
;CPU CAN LOAD/STORE INDIRECTLY IS VIA THE LDA@Y or STA@Y INSTRUCTIONS.
;HOWEVER, THOSE INSTRUCTIONS ONLY WORK IF ADDRESS IS STORED ON PAGE ZERO.
;THE FOLLOWING SUBROUTINES CALCULATE THE EFFECTIVE ADDRESS, THEN CONSTRUCT
;A SUBROUTINE IN RAM THAT DOES THE LDA OR STA USING THAT ADDRESS.

    .DEF STAOPC = $8D   ;OPCODE FOR "STA" INSTRUCTION
    .DEF LDAOPC = $AD   ;OPCODE FOR "LDA" INSTRUCTION
    .DEF RTSOPC = $60   ;OPCODE FOR "RTS" INSTRUCTION

;ROUTINE TO SIMULATE STA@Y MEMADL WHEN MEMADL IS NOT ON PAGE ZERO.

SIMEM:  PHA                 ;SAVE AC FOR LATER
        LDA#    STAOPC      ;SET OPCODE TO "STA"
        JSR     MEMSUB      ;BUILD REST OF "DOINDR" SUBROUTINE
        PLA                 ;FETCH AC VALUE TO STORE
        JMP     DOINDR      ;* PJMP * STORE AND RETURN
    
;ROUTINE TO SIMULATE LDA@Y MEMADL WHEN MEMADL IS NOT ON PAGE ZERO.

LIMEM:  LDA#    LDAOPC      ;SET OPCODE TO "LDA"
        JSR     MEMSUB      ;BUILD REST OF "DOINDR" SUBROUTINE
        JMP     DOINDR      ;* PJMP * LOAD INTO AC AND RETURN   
    
;ROUTINE TO BUILD REST OF "DOINDR" SUBROUTINE

MEMSUB: STA     DOINDR      ;STORE OPCODE
        TYA                 ;CALC EFFECTIVE ADDR AND STORE IT
        CLC
        ADC     MEMADL      ;Y + LOW ORDER BYTE
        STA     IADDRL
        LDA#    0           ;CARRY + 0 + HIGH ORDER BYTE
        ADC     MEMADH
        STA     IADDRH
        LDA#    RTSOPC      ;PLACE "RTS" AT END OF "DOINDR" ROUTINE
        STA     IRET
        RTS 

;ROUTINE TO SIMULATE STA@Y BRKADL WHEN BRKADL IS NOT ON PAGE ZERO.

SIBRK:  PHA                 ;SAVE AC FOR LATER
        LDA#    STAOPC      ;SET OPCODE TO "STA"
        JSR     BRKSUB      ;BUILD REST OF "DOINDR" SUBROUTINE
        PLA                 ;FETCH AC VALUE TO STORE
        JMP     DOINDR      ;* PJMP * STORE AND RETURN
    
;ROUTINE TO SIMULATE LDA@Y BRKADL WHEN BRKADL IS NOT ON PAGE ZERO.

LIBRK:  LDA#    LDAOPC      ;SET OPCODE TO "LDA"
        JSR     BRKSUB      ;BUILD REST OF "DOINDR" SUBROUTINE
        JMP     DOINDR      ;* PJMP * LOAD INTO AC AND RETURN   
    
;ROUTINE TO BUILD REST OF "DOINDR" SUBROUTINE

BRKSUB: STA     DOINDR      ;STORE OPCODE
        TYA                 ;CALC EFFECTIVE ADDR AND STORE IT
        CLC
        ADC     BRKADL      ;Y + LOW ORDER BYTE
        STA     IADDRL
        LDA#    0           ;CARRY + 0 + HIGH ORDER BYTE
        ADC     BRKADH
        STA     IADDRH
        LDA#    RTSOPC      ;PLACE "RTS" AT END OF "DOINDR" ROUTINE
        STA     IRET
        RTS

    .PAGE

MODE:   .BYTE   $40
        .BYTE   $02
        .BYTE   $45
        .BYTE   $03
        .BYTE   $D0
        .BYTE   $08
        .BYTE   $40
        .BYTE   $09
        .BYTE   $30     ;XXXXXXZ0 INSTRS.
        .BYTE   $22
        .BYTE   $45     ;Z=0, LEFT HALF-BYTE
        .BYTE   $33     ;Z=1, RIGHT HALF-BYTE
        .BYTE   $D0
        .BYTE   $08
        .BYTE   $40
        .BYTE   $09
        .BYTE   $40
        .BYTE   $02

        .BYTE   $45
        .BYTE   $33
        .BYTE   $D0
        .BYTE   $08
        .BYTE   $40
        .BYTE   $09
        .BYTE   $40
        .BYTE   $02
        .BYTE   $45
        .BYTE   $B3
        .BYTE   $D0
        .BYTE   $08
        .BYTE   $40
        .BYTE   $09
        .BYTE   $00
        .BYTE   $22
        .BYTE   $44
        .BYTE   $33
        .BYTE   $D0
        .BYTE   $8C
        .BYTE   $44
        .BYTE   $00
        .BYTE   $11
        .BYTE   $22
        .BYTE   $44
        .BYTE   $33
        .BYTE   $D0
        .BYTE   $8C
        .BYTE   $44
        .BYTE   $9A
        .BYTE   $10

        .BYTE   $22
        .BYTE   $44
        .BYTE   $33
        .BYTE   $D0
        .BYTE   $08
        .BYTE   $40
        .BYTE   $09
        .BYTE   $10
        .BYTE   $22
        .BYTE   $44
        .BYTE   $33
        .BYTE   $D0
        .BYTE   $08
        .BYTE   $40
        .BYTE   $09
        .BYTE   $62
        .BYTE   $13     ;YYXXXZ01 INSTRS.
        .BYTE   $78
        .BYTE   $A9

MNEML:  .BYTE   $1C     ;XXXXX000 INSTRS.
        .BYTE   $8A
        .BYTE   $1C
        .BYTE   $23
        .BYTE   $5D
        .BYTE   $8B
        .BYTE   $1B
        .BYTE   $A1
        .BYTE   $9D
        .BYTE   $8A
        .BYTE   $1D
        .BYTE   $23
        .BYTE   $9D
        .BYTE   $8B
        .BYTE   $1D
        .BYTE   $A1
        .BYTE   $00
        .BYTE   $29
        .BYTE   $19
        .BYTE   $AE
        .BYTE   $69
        .BYTE   $A8
        .BYTE   $19
        .BYTE   $23
        .BYTE   $24
        .BYTE   $53
        .BYTE   $1B
        .BYTE   $23
        .BYTE   $24
        .BYTE   $53
        .BYTE   $19
        .BYTE   $A1
        .BYTE   $00     ;XXXYY100 INSTRS.
        .BYTE   $1A

        .BYTE   $5B
        .BYTE   $5B
        .BYTE   $A5
        .BYTE   $69
        .BYTE   $24
        .BYTE   $24
        .BYTE   $AE     ;1XXX1010 INSTRS.
        .BYTE   $AE
        .BYTE   $A8
        .BYTE   $AD
        .BYTE   $29
        .BYTE   $00
        .BYTE   $7C
        .BYTE   $00
        .BYTE   $15     ;XXXYYY10 INSTRS.
        .BYTE   $9C
        .BYTE   $6D
        .BYTE   $9C
        .BYTE   $A5
        .BYTE   $69
        .BYTE   $29
        .BYTE   $53
        .BYTE   $84     ;XXXYYY01 INSTRS.
        .BYTE   $13
        .BYTE   $34
        .BYTE   $11
        .BYTE   $A5
        .BYTE   $69
        .BYTE   $23
        .BYTE   $A0

MNEMR:  .BYTE   $D8     ;XXXXX000 INSTRS.
        .BYTE   $62
        .BYTE   $5A
        .BYTE   $48
        .BYTE   $26
        .BYTE   $62
        .BYTE   $94
        .BYTE   $88
        .BYTE   $54
        .BYTE   $44
        .BYTE   $C8
        .BYTE   $54
        .BYTE   $68
        .BYTE   $44
        .BYTE   $E8
        .BYTE   $94
        .BYTE   $00
        .BYTE   $B4
        .BYTE   $08
        .BYTE   $84
        .BYTE   $74
        .BYTE   $B4
        .BYTE   $28

        .BYTE   $6E
        .BYTE   $74
        .BYTE   $F4
        .BYTE   $CC
        .BYTE   $4A
        .BYTE   $72
        .BYTE   $F2
        .BYTE   $A4
        .BYTE   $8A
        .BYTE   $00     ;XXXYY100 INSTRS.
        .BYTE   $AA
        .BYTE   $A2
        .BYTE   $A2
        .BYTE   $74
        .BYTE   $74
        .BYTE   $74
        .BYTE   $72
        .BYTE   $44     ;1XXX1010 INSTRS.
        .BYTE   $68
        .BYTE   $B2
        .BYTE   $32
        .BYTE   $B2
        .BYTE   $00
        .BYTE   $22
        .BYTE   $00
        .BYTE   $1A     ;XXXYYY10 INSTRS.
        .BYTE   $1A
        .BYTE   $26
        .BYTE   $26
        .BYTE   $72
        .BYTE   $72
        .BYTE   $88
        .BYTE   $C8
        .BYTE   $C4     ;XXXYYY01 INSTRS.
        .BYTE   $CA
        .BYTE   $26
        .BYTE   $48
        .BYTE   $44
        .BYTE   $44
        .BYTE   $A2
        .BYTE   $C8

MODE2:  .BYTE   MODL0-MODLST
        .BYTE   MODL1-MODLST
        .BYTE   MODL2-MODLST
        .BYTE   MODL3-MODLST
        .BYTE   MODL4-MODLST
        .BYTE   MODL5-MODLST
        .BYTE   MODL6-MODLST
        .BYTE   MODL7-MODLST
        .BYTE   MODL8-MODLST
        .BYTE   MODL9-MODLST
        .BYTE   MODL10-MODLST
        .BYTE   MODL11-MODLST

        .BYTE   MODL12-MODLST
        .BYTE   MODL13-MODLST

    .PAGE

        .DEF    MODLST=.

MODL0:  .ASCII  'ERR'   ;(0BBF)

        .BYTE   0
MODL1:  .ASCII  '#'

        .BYTE   0
MODL2:  .ASCII  'Z'

        .BYTE   0
MODL3:  .BYTE   0
MODL4:  .BYTE   0
MODL5:  .ASCII  'A'

        .BYTE   0
MODL6:  .ASCII  'X@'
    
        .BYTE   0
MODL7:  .ASCII  '@Y'
    
        .BYTE   0
MODL8:  .ASCII  'ZX'
    
        .BYTE   0
MODL9:  .ASCII  'X'

        .BYTE   0
MODL10: .ASCII  'Y'

        .BYTE   0
MODL11: .ASCII  '@'

        .BYTE   0
MODL12: .ASCII  'ZY'
    
        .BYTE   0
MODL13: .BYTE   0

    .PAGE

MODE3:  .BYTE   1
        .BYTE   2
        .BYTE   2
        .BYTE   3
        .BYTE   1
        .BYTE   1
        .BYTE   2
        .BYTE   2
        .BYTE   2
        .BYTE   3
        .BYTE   3
        .BYTE   3
        .BYTE   2
        .BYTE   2
    
;BIT MASKS FOR OP CODE TESTING

BIT0:   .BYTE   1
BIT012: .BYTE   7
BIT2:   .BYTE   4
BIT3:   .BYTE   8
BIT4:   .BYTE   16
BIT7:   .BYTE   128 

    .PAGE
    
NMIHND: JMP@    UNMI       ;* PJMP@ * JUMP TO USER'S NMI ROUTINE

    .DEF BIOLOC = .        ;BIOS CODE IS LOCATED RIGHT AFTER DDT

    ;6502 HARDWARE VECTORS
    
    .DEF NMIADDR = $FFFA    ;NMI VECTOR
    .DEF RESADDR = $FFFC    ;RESET VECTOR
    .DEF IRQADDR = $FFFE    ;IRQ/BRK VECTOR
    
    .LOC NMIADDR
    
    .WORD NMIHND    ;ADDRESS OF NMI HANDLER
    
    .LOC RESADDR
    
    .WORD RESET     ;ENTER DDT ON RESET
    
    .LOC IRQADDR
    
    .WORD IRQINT    ;ADDRESS OF IRQ HANDLER
    
    ;LINK TO MACHINE-SPECIFIC BIOS ROUTINES
    
;      .LINK   TLBIO
       .LINK   M6502BIO

    .END
